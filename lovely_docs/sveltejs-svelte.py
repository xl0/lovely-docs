# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_sveltejs-svelte.ipynb.

# %% auto 0
__all__ = ['logger', 'source', 'commit', 'clone_dir', 'doc_dir_path', 'files', 'model', 'jinja_env', 'get_files_from_fs',
           'PageReplySchema', 'DocPage', 'llm_process_page', 'DocDirectory', 'build_markdown_doc_tree',
           'DirReplySchema', 'llm_process_directory']

# %% ../nbs/10_sveltejs-svelte.ipynb 3
from .utils import settings, GitSource, clone_repo
import llm
from llm.models import Usage
from pydantic import BaseModel, Field
from jinja2 import Environment, FileSystemLoader
import asyncio
import json
import shutil
from pathlib import Path
import langsmith as ls
import logging

# %% ../nbs/10_sveltejs-svelte.ipynb 4
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

logger.debug("hello")

# %% ../nbs/10_sveltejs-svelte.ipynb 5
source = settings.sources["sveltejs/svelte"]
assert isinstance(source, GitSource)

commit = clone_repo(source)
source.commit = commit # Replace the literal commit (master) with the hash
clone_dir = settings.git_dir / source.name

# %% ../nbs/10_sveltejs-svelte.ipynb 6
doc_dir_path = clone_dir / source.doc_dir

def get_files_from_fs(root):
    files = []
    for path in root.rglob('*'):
        if path.is_file():
            rel_path = path.relative_to(root)
            depth = len(rel_path.parts) - 1
            files.append((depth, str(rel_path)))
    files.sort(key=lambda x: (x[0], x[1]))
    return [f[1] for f in files]

files = get_files_from_fs(doc_dir_path)

# %% ../nbs/10_sveltejs-svelte.ipynb 8
model = llm.get_async_model(settings.model)
model.key = settings.api_key

# %% ../nbs/10_sveltejs-svelte.ipynb 9
class PageReplySchema(BaseModel):
    better_name: str = Field(description="")
    digest: str = Field(title="Digest, format: markdown", )
    short_digest: str = Field(title="Short digest, format:markdown")
    essence: str = Field(title="Essence, format:txt")
    relevant: bool


# %% ../nbs/10_sveltejs-svelte.ipynb 10
jinja_env = Environment(loader=FileSystemLoader(settings.templates_dir))

class DocPage(BaseModel):
    """Represents a single documentation page"""
    path: Path
    fulltext: str
    name: str = ""
    digest: str = ""
    short_digest: str = ""
    essence: str = ""
    relevant: bool = True
    usage: Usage|None = None

@ls.traceable("chain", name="Process page")
async def llm_process_page(page: DocPage, libname: str, fake=True) -> DocPage:
    logger.debug(f"Processing {page.path}")

    # Load and render template
    template = jinja_env.get_template("process_page.j2")
    inputs = {
        "text": page.fulltext,
        "filename": page.path.name,
        "path": page.path.parent.name + "/",
        "libname": libname
    }
    with ls.trace("Template", "prompt", inputs=inputs) as trace:
        prompt = template.render(**inputs)
        trace.end(outputs=prompt)

    if fake:
        reply = PageReplySchema(
            better_name=f"{page.path.name}-improved",
            digest="summary_markdown",
            short_digest="short_summary_markdown",
            essence="one line",
            relevant=False if page.path.name == "index.md" else True
        )
        usage = Usage(12, 34)
    else:
        with ls.trace("LLM call", "llm", inputs={"prompt": prompt}) as trace:
            res = await (await model.prompt(prompt=prompt, schema=PageReplySchema))
            trace.end(outputs=await res.text())

        with ls.trace("Parse", "parser", inputs={"input": await res.text()}) as trace:
            reply = PageReplySchema.model_validate_json(await res.text())
            trace.end(outputs=reply)
        usage = await res.usage()

    return DocPage(
        path=page.path,
        fulltext=page.fulltext,
        name=reply.better_name,
        digest=reply.digest,
        short_digest=reply.short_digest,
        essence=reply.essence,
        relevant=reply.relevant,
        usage=usage)

# %% ../nbs/10_sveltejs-svelte.ipynb 12
class DocDirectory(BaseModel):
    """Represents a directory in the documentation structure"""
    path: Path
    name: str = ""
    digest: str = ""
    essence: str = ""
    pages: list[DocPage] = Field(default_factory=list)
    subdirs: list['DocDirectory'] = Field(default_factory=list)
    relevant: bool = True
    usage: Usage | None = None

def build_markdown_doc_tree(root:Path, path:Path = Path()) -> DocDirectory:
    assert root.exists() and root.is_dir()
    assert (root/path).exists() and (root/path).is_dir()

    doc_dir = DocDirectory(path=path)

    # Get immediate children only
    for item in sorted((root/path).iterdir()):
        if item.is_file() and item.suffix == '.md':
            # We'll process files later, just record them
            doc_dir.pages.append(DocPage(path=item.relative_to(root), fulltext=item.read_text()))
        if item.is_dir():
            doc_dir.subdirs.append(build_markdown_doc_tree(root, item.relative_to(root)))

    return doc_dir

# %% ../nbs/10_sveltejs-svelte.ipynb 14
class DirReplySchema(BaseModel):
    better_name: str
    digest: str = Field(title="Directory digest, fmt:markdown")
    essence: str
    relevant: bool

@ls.traceable("chain", name="Process directory")
async def llm_process_directory(directory: DocDirectory,  libname: str) -> DocDirectory:
    """Create a summary for a directory based on its relevant pages and subdirectories"""

    # If the directory did not have any relevant pages / subdirs, we should not be called.
    assert any(x for x in directory.pages+directory.subdirs if x.relevant)

    logger.debug(f"Processing {directory.path}")

    template = jinja_env.get_template("process_directory.j2")
    input = {
        "dirname": directory.path.name,
        "path": directory.path.parent.name,
        "pages": [p for p in directory.pages if p.relevant],
        "subdirs": [s for s in directory.subdirs if s.relevant],
        "libname": libname
    }
    with ls.trace("Template", "prompt", inputs=input) as trace:
        prompt = template.render(**input)
        trace.end(outputs=prompt)

    with ls.trace("LLM call", "llm", inputs={"prompt": prompt}) as trace:
        res = await (await model.prompt(prompt=prompt, schema=DirReplySchema))
        trace.end(outputs=await res.text())
        usage = await res.usage()

    with ls.trace("Parse", "parser", inputs={"input": await res.text()}) as trace:
        reply = DirReplySchema.model_validate_json(await res.text())
        trace.end(outputs=reply)

    res = directory.model_copy(deep=True)
    res.name = reply.better_name
    res.digest = reply.digest
    res.essence = reply.essence
    res.relevant = reply.relevant
    res.usage = usage
    return res
