{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Miscellaneous/typescript",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","07-misc/03-typescript.md",true,{"fulltext":8,"digest":9,"short_digest":10},2954,805,299,{"input":12,"output":13,"details":14},3991,1221,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: TypeScript\n---\n\n\u003C!-- - [basically what we have today](https://svelte.dev/docs/typescript)\n- built-in support, but only for type-only features\n- generics\n- using `Component` and the other helper types\n- using `svelte-check` -->\n\nYou can use TypeScript within Svelte components. IDE extensions like the [Svelte VS Code extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode) will help you catch errors right in your editor, and [`svelte-check`](https://www.npmjs.com/package/svelte-check) does the same on the command line, which you can integrate into your CI.\n\n## `\u003Cscript lang=\"ts\">`\n\nTo use TypeScript inside your Svelte components, add `lang=\"ts\"` to your `script` tags:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\tlet name: string = 'world';\n\n\tfunction greet(name: string) {\n\t\talert(`Hello, ${name}!`);\n\t}\n\u003C/script>\n\n\u003Cbutton onclick={(e: Event) => greet(e.target.innerText)}>\n\t{name as string}\n\u003C/button>\n```\n\nDoing so allows you to use TypeScript's _type-only_ features. That is, all features that just disappear when transpiling to JavaScript, such as type annotations or interface declarations. Features that require the TypeScript compiler to output actual code are not supported. This includes:\n\n- using enums\n- using `private`, `protected` or `public` modifiers in constructor functions together with initializers\n- using features that are not yet part of the ECMAScript standard (i.e. not level 4 in the TC39 process) and therefore not implemented yet within Acorn, the parser we use for parsing JavaScript\n\nIf you want to use one of these features, you need to setup up a `script` preprocessor.\n\n## Preprocessor setup\n\nTo use non-type-only TypeScript features within Svelte components, you need to add a preprocessor that will turn TypeScript into JavaScript.\n\n```ts\n/// file: svelte.config.js\n// @noErrors\nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\nconst config = {\n\t// Note the additional `{ script: true }`\n\tpreprocess: vitePreprocess({ script: true })\n};\n\nexport default config;\n```\n\n### Using SvelteKit or Vite\n\nThe easiest way to get started is scaffolding a new SvelteKit project by typing `npx sv create`, following the prompts and choosing the TypeScript option.\n\n```ts\n/// file: svelte.config.js\n// @noErrors\nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\nconst config = {\n\tpreprocess: vitePreprocess()\n};\n\nexport default config;\n```\n\nIf you don't need or want all the features SvelteKit has to offer, you can scaffold a Svelte-flavoured Vite project instead by typing `npm create vite@latest` and selecting the `svelte-ts` option.\n\nIn both cases, a `svelte.config.js` with `vitePreprocess` will be added. Vite/SvelteKit will read from this config file.\n\n### Other build tools\n\nIf you're using tools like Rollup or Webpack instead, install their respective Svelte plugins. For Rollup that's [rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte) and for Webpack that's [svelte-loader](https://github.com/sveltejs/svelte-loader). For both, you need to install `typescript` and `svelte-preprocess` and add the preprocessor to the plugin config (see the respective READMEs for more info). If you're starting a new project, you can also use the [rollup](https://github.com/sveltejs/template) or [webpack](https://github.com/sveltejs/template-webpack) template to scaffold the setup from a script.\n\n> [!NOTE] If you're starting a new project, we recommend using SvelteKit or Vite instead\n\n## tsconfig.json settings\n\nWhen using TypeScript, make sure your `tsconfig.json` is setup correctly.\n\n- Use a [`target`](https://www.typescriptlang.org/tsconfig/#target) of at least `ES2015` so classes are not compiled to functions\n- Set [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax) to `true` so that imports are left as-is\n- Set [`isolatedModules`](https://www.typescriptlang.org/tsconfig/#isolatedModules) to `true` so that each file is looked at in isolation. TypeScript has a few features which require cross-file analysis and compilation, which the Svelte compiler and tooling like Vite don't do. \n\n## Typing `$props`\n\nType `$props` just like a regular object with certain properties.\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\n\tinterface Props {\n\t\trequiredProperty: number;\n\t\toptionalProperty?: boolean;\n\t\tsnippetWithStringArgument: Snippet\u003C[string]>;\n\t\teventHandler: (arg: string) => void;\n\t\t[key: string]: unknown;\n\t}\n\n\tlet {\n\t\trequiredProperty,\n\t\toptionalProperty,\n\t\tsnippetWithStringArgument,\n\t\teventHandler,\n\t\t...everythingElse\n\t}: Props = $props();\n\u003C/script>\n\n\u003Cbutton onclick={() => eventHandler('clicked button')}>\n\t{@render snippetWithStringArgument('hello')}\n\u003C/button>\n```\n\n## Generic `$props`\n\nComponents can declare a generic relationship between their properties. One example is a generic list component that receives a list of items and a callback property that receives an item from the list. To declare that the `items` property and the `select` callback operate on the same types, add the `generics` attribute to the `script` tag:\n\n```svelte\n\u003Cscript lang=\"ts\" generics=\"Item extends { text: string }\">\n\tinterface Props {\n\t\titems: Item[];\n\t\tselect(item: Item): void;\n\t}\n\n\tlet { items, select }: Props = $props();\n\u003C/script>\n\n{#each items as item}\n\t\u003Cbutton onclick={() => select(item)}>\n\t\t{item.text}\n\t\u003C/button>\n{/each}\n```\n\nThe content of `generics` is what you would put between the `\u003C...>` tags of a generic function. In other words, you can use multiple generics, `extends` and fallback types.\n\n## Typing wrapper components\n\nIn case you're writing a component that wraps a native element, you may want to expose all the attributes of the underlying element to the user. In that case, use (or extend from) one of the interfaces provided by `svelte/elements`. Here's an example for a `Button` component:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { HTMLButtonAttributes } from 'svelte/elements';\n\n\tlet { children, ...rest }: HTMLButtonAttributes = $props();\n\u003C/script>\n\n\u003Cbutton {...rest}>\n\t{@render children?.()}\n\u003C/button>\n```\n\nNot all elements have a dedicated type definition. For those without one, use `SvelteHTMLElements`:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { SvelteHTMLElements } from 'svelte/elements';\n\n\tlet { children, ...rest }: SvelteHTMLElements['div'] = $props();\n\u003C/script>\n\n\u003Cdiv {...rest}>\n\t{@render children?.()}\n\u003C/div>\n```\n\n## Typing `$state`\n\nYou can type `$state` like any other variable.\n\n```ts\nlet count: number = $state(0);\n```\n\nIf you don't give `$state` an initial value, part of its types will be `undefined`.\n\n```ts\n// @noErrors\n// Error: Type 'number | undefined' is not assignable to type 'number'\nlet count: number = $state();\n```\n\nIf you know that the variable _will_ be defined before you first use it, use an `as` casting. This is especially useful in the context of classes:\n\n```ts\nclass Counter {\n\tcount = $state() as number;\n\tconstructor(initial: number) {\n\t\tthis.count = initial;\n\t}\n}\n```\n\n## The `Component` type\n\nSvelte components are of type `Component`. You can use it and its related types to express a variety of constraints.\n\nUsing it together with dynamic components to restrict what kinds of component can be passed to it:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { Component } from 'svelte';\n\n\tinterface Props {\n\t\t// only components that have at most the \"prop\"\n\t\t// property required can be passed\n\t\tDynamicComponent: Component\u003C{ prop: string }>;\n\t}\n\n\tlet { DynamicComponent }: Props = $props();\n\u003C/script>\n\n\u003CDynamicComponent prop=\"foo\" />\n```\n\n> [!LEGACY] In Svelte 4, components were of type `SvelteComponent`\n\nTo extract the properties from a component, use `ComponentProps`.\n\n```ts\nimport type { Component, ComponentProps } from 'svelte';\nimport MyComponent from './MyComponent.svelte';\n\nfunction withProps\u003CTComponent extends Component\u003Cany>>(\n\tcomponent: TComponent,\n\tprops: ComponentProps\u003CTComponent>\n) {}\n\n// Errors if the second argument is not the correct props expected\n// by the component in the first argument.\nwithProps(MyComponent, { foo: 'bar' });\n```\n\nTo declare that a variable expects the constructor or instance type of a component:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport MyComponent from './MyComponent.svelte';\n\n\tlet componentConstructor: typeof MyComponent = MyComponent;\n\tlet componentInstance: MyComponent;\n\u003C/script>\n\n\u003CMyComponent bind:this={componentInstance} />\n```\n\n## Enhancing built-in DOM types\n\nSvelte provides a best effort of all the HTML DOM types that exist. Sometimes you may want to use experimental attributes or custom events coming from an action. In these cases, TypeScript will throw a type error, saying that it does not know these types. If it's a non-experimental standard attribute/event, this may very well be a missing typing from our [HTML typings](https://github.com/sveltejs/svelte/blob/main/packages/svelte/elements.d.ts). In that case, you are welcome to open an issue and/or a PR fixing it.\n\nIn case this is a custom or experimental attribute/event, you can enhance the typings like this:\n\n```ts\n/// file: additional-svelte-typings.d.ts\ndeclare namespace svelteHTML {\n\t// enhance elements\n\tinterface IntrinsicElements {\n\t\t'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent\u003Cany>) => void };\n\t}\n\t// enhance attributes\n\tinterface HTMLAttributes\u003CT> {\n\t\t// If you want to use the beforeinstallprompt event\n\t\tonbeforeinstallprompt?: (event: any) => any;\n\t\t// If you want to use myCustomAttribute={..} (note: all lowercase)\n\t\tmycustomattribute?: any; // You can replace any with something more specific if you like\n\t}\n}\n```\n\nThen make sure that `d.ts` file is referenced in your `tsconfig.json`. If it reads something like `\"include\": [\"src/**/*\"]` and your `d.ts` file is inside `src`, it should work. You may need to reload for the changes to take effect.\n\nYou can also declare the typings by augmenting the `svelte/elements` module like this:\n\n```ts\n/// file: additional-svelte-typings.d.ts\nimport { HTMLButtonAttributes } from 'svelte/elements';\n\ndeclare module 'svelte/elements' {\n\texport interface SvelteHTMLElements {\n\t\t'custom-button': HTMLButtonAttributes;\n\t}\n\n\t// allows for more granular control over what element to add the typings to\n\texport interface HTMLButtonAttributes {\n\t\tveryexperimentalattribute?: string;\n\t}\n}\n\nexport {}; // ensure this is not an ambient module, else types will be overridden instead of augmented\n```\n","## Using TypeScript in Svelte\n\nAdd `lang=\"ts\"` to script tags to enable TypeScript. Only type-only features are supported by default (type annotations, interfaces, generics). Features requiring code generation (enums, constructor modifiers with initializers, non-standard ECMAScript features) need a preprocessor.\n\n## Preprocessor Setup\n\nFor full TypeScript support, configure `vitePreprocess` in `svelte.config.js`:\n\n```ts\nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\nconst config = { preprocess: vitePreprocess({ script: true }) };\nexport default config;\n```\n\nSvelteKit and Vite projects include this automatically. For Rollup/Webpack, use `rollup-plugin-svelte` or `svelte-loader` with `svelte-preprocess`.\n\n## tsconfig.json Requirements\n\n- Set `target` to at least `ES2015`\n- Set `verbatimModuleSyntax` to `true`\n- Set `isolatedModules` to `true`\n\n## Typing Props\n\nType `$props()` as a regular object:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\trequiredProperty: number;\n\t\toptionalProperty?: boolean;\n\t\tsnippetWithStringArgument: Snippet\u003C[string]>;\n\t\teventHandler: (arg: string) => void;\n\t}\n\tlet { requiredProperty, optionalProperty, snippetWithStringArgument, eventHandler }: Props = $props();\n\u003C/script>\n```\n\n## Generic Props\n\nUse the `generics` attribute on script tags to declare generic relationships:\n\n```svelte\n\u003Cscript lang=\"ts\" generics=\"Item extends { text: string }\">\n\tinterface Props {\n\t\titems: Item[];\n\t\tselect(item: Item): void;\n\t}\n\tlet { items, select }: Props = $props();\n\u003C/script>\n```\n\n## Typing Wrapper Components\n\nUse `HTMLButtonAttributes` from `svelte/elements` for native element wrappers, or `SvelteHTMLElements['div']` for elements without dedicated types.\n\n## Typing State\n\nType `$state` like regular variables. Use `as` casting when initial value is undefined but will be set before use:\n\n```ts\nlet count: number = $state(0);\nclass Counter {\n\tcount = $state() as number;\n}\n```\n\n## Component Types\n\nThe `Component` type constrains what components can be passed:\n\n```ts\nimport type { Component, ComponentProps } from 'svelte';\ninterface Props {\n\tDynamicComponent: Component\u003C{ prop: string }>;\n}\n```\n\nExtract component props with `ComponentProps\u003CTComponent>`. Access component constructors with `typeof MyComponent` and instances with `MyComponent` type.\n\n## Enhancing DOM Types\n\nExtend built-in types for custom/experimental attributes and events by declaring in a `.d.ts` file:\n\n```ts\ndeclare namespace svelteHTML {\n\tinterface IntrinsicElements {\n\t\t'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent) => void };\n\t}\n\tinterface HTMLAttributes\u003CT> {\n\t\tonbeforeinstallprompt?: (event: any) => any;\n\t}\n}\n```\n\nOr augment the `svelte/elements` module directly.","## TypeScript in Svelte\n\nAdd `lang=\"ts\"` to script tags for type-only features. For full TypeScript support, configure `vitePreprocess` in `svelte.config.js`.\n\nSet `tsconfig.json`: `target: ES2015`, `verbatimModuleSyntax: true`, `isolatedModules: true`.\n\n## Typing Props and State\n\n```svelte\n\u003Cscript lang=\"ts\" generics=\"Item extends { text: string }\">\n\tinterface Props {\n\t\titems: Item[];\n\t\tselect(item: Item): void;\n\t}\n\tlet { items, select }: Props = $props();\n\tlet count: number = $state(0);\n\u003C/script>\n```\n\n## Component Types\n\n```ts\nimport type { Component, ComponentProps } from 'svelte';\ninterface Props {\n\tDynamicComponent: Component\u003C{ prop: string }>;\n}\n```\n\n## Enhancing DOM Types\n\nExtend custom attributes/events in a `.d.ts` file:\n\n```ts\ndeclare namespace svelteHTML {\n\tinterface IntrinsicElements {\n\t\t'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent) => void };\n\t}\n}\n```","Using TypeScript in Svelte components with type annotations, preprocessor setup, prop/state typing, generics, and DOM type augmentation."],"uses":{"params":["name","path"]}}]}
