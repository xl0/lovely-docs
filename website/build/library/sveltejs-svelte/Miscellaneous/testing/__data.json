{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Miscellaneous/testing",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","07-misc/02-testing.md",true,{"fulltext":8,"digest":9,"short_digest":10},2532,843,252,{"input":12,"output":13,"details":14},3569,1218,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Testing\n---\n\nTesting helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use â€” you can write unit tests, integration tests, and end-to-end tests using solutions like [Vitest](https://vitest.dev/), [Jasmine](https://jasmine.github.io/), [Cypress](https://www.cypress.io/) and [Playwright](https://playwright.dev/).\n\n## Unit and integration testing using Vitest\n\nUnit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/). You can use the Svelte CLI to [setup Vitest](/docs/cli/vitest) either during project creation or later on.\n\nTo setup Vitest manually, first install it:\n\n```bash\nnpm install -D vitest\n```\n\nThen adjust your `vite.config.js`:\n\n\u003C!-- prettier-ignore -->\n```js\n/// file: vite.config.js\nimport { defineConfig } from +++'vitest/config'+++;\n\nexport default defineConfig({\n\t// ...\n\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n\tresolve: process.env.VITEST\n\t\t? {\n\t\t\t\tconditions: ['browser']\n\t\t\t}\n\t\t: undefined\n});\n```\n\n> [!NOTE] If loading the browser version of all your packages is undesirable, because (for example) you also test backend libraries, [you may need to resort to an alias configuration](https://github.com/testing-library/svelte-testing-library/issues/222#issuecomment-1909993331)\n\nYou can now write unit tests for code inside your `.js/.ts` files:\n\n```js\n/// file: multiplier.svelte.test.js\nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { multiplier } from './multiplier.svelte.js';\n\ntest('Multiplier', () => {\n\tlet double = multiplier(0, 2);\n\n\texpect(double.value).toEqual(0);\n\n\tdouble.set(5);\n\n\texpect(double.value).toEqual(10);\n});\n```\n\n```js\n/// file: multiplier.svelte.js\n/**\n * @param {number} initial\n * @param {number} k\n */\nexport function multiplier(initial, k) {\n\tlet count = $state(initial);\n\n\treturn {\n\t\tget value() {\n\t\t\treturn count * k;\n\t\t},\n\t\t/** @param {number} c */\n\t\tset: (c) => {\n\t\t\tcount = c;\n\t\t}\n\t};\n}\n```\n\n### Using runes inside your test files\n\nSince Vitest processes your test files the same way as your source files, you can use runes inside your tests as long as the filename includes `.svelte`:\n\n```js\n/// file: multiplier.svelte.test.js\nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { multiplier } from './multiplier.svelte.js';\n\ntest('Multiplier', () => {\n\tlet count = $state(0);\n\tlet double = multiplier(() => count, 2);\n\n\texpect(double.value).toEqual(0);\n\n\tcount = 5;\n\n\texpect(double.value).toEqual(10);\n});\n```\n\n```js\n/// file: multiplier.svelte.js\n/**\n * @param {() => number} getCount\n * @param {number} k\n */\nexport function multiplier(getCount, k) {\n\treturn {\n\t\tget value() {\n\t\t\treturn getCount() * k;\n\t\t}\n\t};\n}\n```\n\nIf the code being tested uses effects, you need to wrap the test inside `$effect.root`:\n\n```js\n/// file: logger.svelte.test.js\nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { logger } from './logger.svelte.js';\n\ntest('Effect', () => {\n\tconst cleanup = $effect.root(() => {\n\t\tlet count = $state(0);\n\n\t\t// logger uses an $effect to log updates of its input\n\t\tlet log = logger(() => count);\n\n\t\t// effects normally run after a microtask,\n\t\t// use flushSync to execute all pending effects synchronously\n\t\tflushSync();\n\t\texpect(log).toEqual([0]);\n\n\t\tcount = 1;\n\t\tflushSync();\n\n\t\texpect(log).toEqual([0, 1]);\n\t});\n\n\tcleanup();\n});\n```\n\n```js\n/// file: logger.svelte.js\n/**\n * @param {() => any} getValue\n */\nexport function logger(getValue) {\n\t/** @type {any[]} */\n\tlet log = [];\n\n\t$effect(() => {\n\t\tlog.push(getValue());\n\t});\n\n\treturn log;\n}\n```\n\n### Component testing\n\nIt is possible to test your components in isolation using Vitest.\n\n> [!NOTE] Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\n\nTo get started, install jsdom (a library that shims DOM APIs):\n\n```bash\nnpm install -D jsdom\n```\n\nThen adjust your `vite.config.js`:\n\n```js\n/// file: vite.config.js\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n\tplugins: [\n\t\t/* ... */\n\t],\n\ttest: {\n\t\t// If you are testing components client-side, you need to setup a DOM environment.\n\t\t// If not all your files should have this environment, you can use a\n\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n\t\tenvironment: 'jsdom'\n\t},\n\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n\tresolve: process.env.VITEST\n\t\t? {\n\t\t\t\tconditions: ['browser']\n\t\t\t}\n\t\t: undefined\n});\n```\n\nAfter that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:\n\n```js\n/// file: component.test.js\nimport { flushSync, mount, unmount } from 'svelte';\nimport { expect, test } from 'vitest';\nimport Component from './Component.svelte';\n\ntest('Component', () => {\n\t// Instantiate the component using Svelte's `mount` API\n\tconst component = mount(Component, {\n\t\ttarget: document.body, // `document` exists because of jsdom\n\t\tprops: { initial: 0 }\n\t});\n\n\texpect(document.body.innerHTML).toBe('\u003Cbutton>0\u003C/button>');\n\n\t// Click the button, then flush the changes so you can synchronously write expectations\n\tdocument.body.querySelector('button').click();\n\tflushSync();\n\n\texpect(document.body.innerHTML).toBe('\u003Cbutton>1\u003C/button>');\n\n\t// Remove the component from the DOM\n\tunmount(component);\n});\n```\n\nWhile the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests. The above test could be rewritten like this:\n\n```js\n/// file: component.test.js\nimport { render, screen } from '@testing-library/svelte';\nimport userEvent from '@testing-library/user-event';\nimport { expect, test } from 'vitest';\nimport Component from './Component.svelte';\n\ntest('Component', async () => {\n\tconst user = userEvent.setup();\n\trender(Component);\n\n\tconst button = screen.getByRole('button');\n\texpect(button).toHaveTextContent(0);\n\n\tawait user.click(button);\n\texpect(button).toHaveTextContent(1);\n});\n```\n\nWhen writing component tests that involve two-way bindings, context or snippet props, it's best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some [examples](https://testing-library.com/docs/svelte-testing-library/example).\n\n## E2E tests using Playwright\n\nE2E (short for 'end to end') tests allow you to test your full application through the eyes of the user. This section uses [Playwright](https://playwright.dev/) as an example, but you can also use other solutions like [Cypress](https://www.cypress.io/) or [NightwatchJS](https://nightwatchjs.org/).\n\nYou can use the Svelte CLI to [setup Playwright](/docs/cli/playwright) either during project creation or later on. You can also [set it up with `npm init playwright`](https://playwright.dev/docs/intro). Additionally, you may also want to install an IDE plugin such as [the VS Code extension](https://playwright.dev/docs/getting-started-vscode) to be able to execute tests from inside your IDE.\n\nIf you've run `npm init playwright` or are not using Vite, you may need to adjust the Playwright config to tell Playwright what to do before running the tests - mainly starting your application at a certain port. For example:\n\n```js\n/// file: playwright.config.js\nconst config = {\n\twebServer: {\n\t\tcommand: 'npm run build && npm run preview',\n\t\tport: 4173\n\t},\n\ttestDir: 'tests',\n\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n};\n\nexport default config;\n```\n\nYou can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.\n\n```js\n// @errors: 2307 7031\n/// file: tests/hello-world.spec.js\nimport { expect, test } from '@playwright/test';\n\ntest('home page has expected h1', async ({ page }) => {\n\tawait page.goto('/');\n\tawait expect(page.locator('h1')).toBeVisible();\n});\n```\n","## Unit and Integration Testing with Vitest\n\nInstall Vitest and configure `vite.config.js` to use browser entry points:\n\n```js\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n\tresolve: process.env.VITEST\n\t\t? { conditions: ['browser'] }\n\t\t: undefined\n});\n```\n\nWrite unit tests for `.js/.ts` files:\n\n```js\nimport { expect, test } from 'vitest';\nimport { multiplier } from './multiplier.svelte.js';\n\ntest('Multiplier', () => {\n\tlet double = multiplier(0, 2);\n\texpect(double.value).toEqual(0);\n\tdouble.set(5);\n\texpect(double.value).toEqual(10);\n});\n```\n\n### Using Runes in Tests\n\nTest files with `.svelte` in the filename can use runes. For effects, wrap tests in `$effect.root()` and use `flushSync()` to execute pending effects synchronously:\n\n```js\ntest('Effect', () => {\n\tconst cleanup = $effect.root(() => {\n\t\tlet count = $state(0);\n\t\tlet log = logger(() => count);\n\t\tflushSync();\n\t\texpect(log).toEqual([0]);\n\t\tcount = 1;\n\t\tflushSync();\n\t\texpect(log).toEqual([0, 1]);\n\t});\n\tcleanup();\n});\n```\n\n### Component Testing\n\nInstall jsdom and configure `vite.config.js` with `environment: 'jsdom'`. Use Svelte's `mount` API:\n\n```js\nimport { mount, unmount, flushSync } from 'svelte';\nimport Component from './Component.svelte';\n\ntest('Component', () => {\n\tconst component = mount(Component, {\n\t\ttarget: document.body,\n\t\tprops: { initial: 0 }\n\t});\n\texpect(document.body.innerHTML).toBe('\u003Cbutton>0\u003C/button>');\n\tdocument.body.querySelector('button').click();\n\tflushSync();\n\texpect(document.body.innerHTML).toBe('\u003Cbutton>1\u003C/button>');\n\tunmount(component);\n});\n```\n\nFor higher-level testing, use `@testing-library/svelte`:\n\n```js\nimport { render, screen } from '@testing-library/svelte';\nimport userEvent from '@testing-library/user-event';\n\ntest('Component', async () => {\n\tconst user = userEvent.setup();\n\trender(Component);\n\tconst button = screen.getByRole('button');\n\texpect(button).toHaveTextContent(0);\n\tawait user.click(button);\n\texpect(button).toHaveTextContent(1);\n});\n```\n\nFor tests with two-way bindings, context, or snippet props, create a wrapper component.\n\n## E2E Testing with Playwright\n\nConfigure `playwright.config.js` to start your application:\n\n```js\nconst config = {\n\twebServer: {\n\t\tcommand: 'npm run build && npm run preview',\n\t\tport: 4173\n\t},\n\ttestDir: 'tests',\n\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n};\nexport default config;\n```\n\nWrite tests that interact with the DOM:\n\n```js\nimport { expect, test } from '@playwright/test';\n\ntest('home page has expected h1', async ({ page }) => {\n\tawait page.goto('/');\n\tawait expect(page.locator('h1')).toBeVisible();\n});\n```","## Unit/Integration Testing with Vitest\n\nConfigure `vite.config.js` to use browser entry points. Test files with `.svelte` in the name can use runes. Wrap effect tests in `$effect.root()` and use `flushSync()` for synchronous execution.\n\n```js\ntest('Multiplier', () => {\n\tlet double = multiplier(0, 2);\n\texpect(double.value).toEqual(0);\n});\n```\n\n## Component Testing\n\nUse `mount()` API or `@testing-library/svelte` for higher-level testing:\n\n```js\nconst component = mount(Component, { target: document.body, props: { initial: 0 } });\n```\n\n## E2E Testing with Playwright\n\nConfigure `playwright.config.js` with webServer settings and write tests that interact with the DOM:\n\n```js\ntest('home page has expected h1', async ({ page }) => {\n\tawait page.goto('/');\n\tawait expect(page.locator('h1')).toBeVisible();\n});\n```","Guide to testing Svelte applications using Vitest for unit/integration tests, component testing with mount API or testing-library, and Playwright for E2E tests."],"uses":{"params":["name","path"]}}]}
