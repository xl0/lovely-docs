{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Miscellaneous/custom-elements",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","07-misc/04-custom-elements.md",true,{"fulltext":8,"digest":9,"short_digest":10},2035,739,202,{"input":12,"output":13,"details":14},3074,1048,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Custom elements\n---\n\n\u003C!-- - [basically what we have today](https://svelte.dev/docs/custom-elements-api) -->\n\nSvelte components can also be compiled to custom elements (aka web components) using the `customElement: true` compiler option. You should specify a tag name for the component using the `\u003Csvelte:options>` [element](svelte-options).\n\n```svelte\n\u003Csvelte:options customElement=\"my-element\" />\n\n\u003Cscript>\n\tlet { name = 'world' } = $props();\n\u003C/script>\n\n\u003Ch1>Hello {name}!\u003C/h1>\n\u003Cslot />\n```\n\nYou can leave out the tag name for any of your inner components which you don't want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static `element` property which contains the custom element constructor and which is available when the `customElement` compiler option is `true`.\n\n```js\n// @noErrors\nimport MyElement from './MyElement.svelte';\n\ncustomElements.define('my-element', MyElement.element);\n```\n\nOnce a custom element has been defined, it can be used as a regular DOM element:\n\n```js\ndocument.body.innerHTML = `\n\t\u003Cmy-element>\n\t\t\u003Cp>This is some slotted content\u003C/p>\n\t\u003C/my-element>\n`;\n```\n\nAny [props](basic-markup#Component-props) are exposed as properties of the DOM element (as well as being readable/writable as attributes, where possible).\n\n```js\n// @noErrors\nconst el = document.querySelector('my-element');\n\n// get the current value of the 'name' prop\nconsole.log(el.name);\n\n// set a new value, updating the shadow DOM\nel.name = 'everybody';\n```\n\nNote that you need to list out all properties explicitly, i.e. doing `let props = $props()` without declaring `props` in the [component options](#Component-options) means that Svelte can't know which props to expose as properties on the DOM element.\n\n## Component lifecycle\n\nCustom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.\n\nWhen a custom element is created, the Svelte component it wraps is _not_ created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the [`extend` option](#Component-options).\n\nWhen a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don't lead to unmounting the inner component.\n\nThe inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked.\n\n## Component options\n\nWhen constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `\u003Csvelte:options>` since Svelte 4. This object may contain the following properties:\n\n- `tag: string`: an optional `tag` property for the custom element's name. If set, a custom element with this tag name will be defined with the document's `customElements` registry upon importing this component.\n- `shadow`: an optional property that can be set to `\"none\"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can't use slots\n- `props`: an optional property to modify certain details and behaviors of your component's properties. It offers the following settings:\n  - `attribute: string`: To update a custom element's prop, you have two alternatives: either set the property on the custom element's reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: \"\u003Cdesired name>\"`.\n  - `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`.\n  - `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: \"Number\"`\n    You don't need to list all properties, those not listed will use the default settings.\n- `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use [ElementInternals](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals#examples) for better HTML form integration.\n\n```svelte\n\u003Csvelte:options\n\tcustomElement={{\n\t\ttag: 'custom-element',\n\t\tshadow: 'none',\n\t\tprops: {\n\t\t\tname: { reflect: true, type: 'Number', attribute: 'element-index' }\n\t\t},\n\t\textend: (customElementConstructor) => {\n\t\t\t// Extend the class so we can let it participate in HTML forms\n\t\t\treturn class extends customElementConstructor {\n\t\t\t\tstatic formAssociated = true;\n\n\t\t\t\tconstructor() {\n\t\t\t\t\tsuper();\n\t\t\t\t\tthis.attachedInternals = this.attachInternals();\n\t\t\t\t}\n\n\t\t\t\t// Add the function here, not below in the component so that\n\t\t\t\t// it's always available, not just when the inner Svelte component\n\t\t\t\t// is mounted\n\t\t\t\trandomIndex() {\n\t\t\t\t\tthis.elementIndex = Math.random();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}}\n/>\n\n\u003Cscript>\n\tlet { elementIndex, attachedInternals } = $props();\n\t// ...\n\tfunction check() {\n\t\tattachedInternals.checkValidity();\n\t}\n\u003C/script>\n\n...\n```\n\n> [!NOTE] While Typescript is supported in the `extend` function, it is subject to limitations: you need to set `lang=\"ts\"` on one of the scripts AND you can only use [erasable syntax](https://www.typescriptlang.org/tsconfig/#erasableSyntaxOnly) in it. They are not processed by script preprocessors.\n\n## Caveats and limitations\n\nCustom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as [most frameworks](https://custom-elements-everywhere.com/). There are, however, some important differences to be aware of:\n\n- Styles are _encapsulated_, rather than merely _scoped_ (unless you set `shadow: \"none\"`). This means that any non-component styles (such as you might have in a `global.css` file) will not apply to the custom element, including styles with the `:global(...)` modifier\n- Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string\n- Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads\n- In Svelte, slotted content renders _lazily_. In the DOM, it renders _eagerly_. In other words, it will always be created even if the component's `\u003Cslot>` element is inside an `{#if ...}` block. Similarly, including a `\u003Cslot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times\n- The deprecated `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot\n- Polyfills are required to support older browsers\n- You can use Svelte's context feature between regular Svelte components within a custom element, but you can't use them across custom elements. In other words, you can't use `setContext` on a parent custom element and read that with `getContext` in a child custom element.\n- Don't declare properties or attributes starting with `on`, as their usage will be interpreted as an event listener. In other words, Svelte treats `\u003Ccustom-element oneworld={true}>\u003C/custom-element>` as `customElement.addEventListener('eworld', true)` (and not as `customElement.oneworld = true`)\n","## Compiling to Custom Elements\n\nSvelte components can be compiled to web components using `customElement: true` compiler option. Specify a tag name with `\u003Csvelte:options customElement=\"my-element\" />`.\n\n```svelte\n\u003Csvelte:options customElement=\"my-element\" />\n\u003Cscript>\n\tlet { name = 'world' } = $props();\n\u003C/script>\n\u003Ch1>Hello {name}!\u003C/h1>\n\u003Cslot />\n```\n\nInner components without a tag name remain regular Svelte components. Access the custom element constructor via the static `element` property:\n\n```js\nimport MyElement from './MyElement.svelte';\ncustomElements.define('my-element', MyElement.element);\n```\n\nUse as regular DOM elements with props exposed as properties and attributes:\n\n```js\nconst el = document.querySelector('my-element');\nconsole.log(el.name);\nel.name = 'everybody';\n```\n\n## Lifecycle\n\nThe Svelte component is created in the next tick after `connectedCallback`. Properties assigned before DOM insertion are saved and applied on creation. Exported functions are only available after mounting. Shadow DOM updates batch in the next tick. The component is destroyed in the next tick after `disconnectedCallback`.\n\n## Advanced Configuration\n\nDefine `customElement` as an object in `\u003Csvelte:options>`:\n\n- `tag: string` - Custom element tag name, auto-registers if set\n- `shadow: \"none\"` - Disable shadow root (disables style encapsulation and slots)\n- `props` - Configure individual properties:\n  - `attribute: string` - Custom attribute name (default: lowercase property name)\n  - `reflect: boolean` - Reflect prop changes back to DOM\n  - `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'` - Type for attribute conversion\n- `extend: function` - Receives custom element class, return extended class for lifecycle customization or ElementInternals integration\n\n```svelte\n\u003Csvelte:options\n\tcustomElement={{\n\t\ttag: 'custom-element',\n\t\tshadow: 'none',\n\t\tprops: {\n\t\t\tname: { reflect: true, type: 'Number', attribute: 'element-index' }\n\t\t},\n\t\textend: (customElementConstructor) => {\n\t\t\treturn class extends customElementConstructor {\n\t\t\t\tstatic formAssociated = true;\n\t\t\t\tconstructor() {\n\t\t\t\t\tsuper();\n\t\t\t\t\tthis.attachedInternals = this.attachInternals();\n\t\t\t\t}\n\t\t\t\trandomIndex() {\n\t\t\t\t\tthis.elementIndex = Math.random();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}}\n/>\n```\n\n## Important Caveats\n\n- Styles are encapsulated in shadow DOM (unless `shadow: \"none\"`), so global styles don't apply\n- Styles are inlined as JavaScript strings, not extracted to CSS files\n- Not suitable for server-side rendering\n- Slotted content renders eagerly in DOM (not lazily like in Svelte)\n- `let:` directive has no effect\n- Context cannot cross custom element boundaries\n- Don't use property/attribute names starting with `on` (interpreted as event listeners)","## Custom Elements\n\nCompile Svelte components to web components with `customElement: true` and `\u003Csvelte:options customElement=\"tag-name\" />`. Props are exposed as DOM properties and attributes.\n\nAdvanced configuration via object in `\u003Csvelte:options>`:\n- `tag` - Auto-register with this tag name\n- `shadow: \"none\"` - Disable shadow DOM\n- `props` - Configure per-property: `attribute`, `reflect`, `type`\n- `extend` - Function to extend the custom element class\n\n```svelte\n\u003Csvelte:options customElement={{ tag: 'my-element', props: { name: { reflect: true } } }} />\n```\n\nKey limitations: styles are encapsulated, not SSR-friendly, slotted content renders eagerly, context doesn't cross custom element boundaries, avoid property names starting with `on`.","How to compile Svelte components to web components and configure their behavior, properties, and lifecycle."],"uses":{"params":["name","path"]}}]}
