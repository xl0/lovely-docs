{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","API Reference/Error & Warning Reference/client-errors",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","98-reference/.generated/client-errors.md",true,{"fulltext":8,"digest":9,"short_digest":10},1198,642,159,{"input":12,"output":13,"details":14},2234,917,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"\u003C!-- This file is generated by scripts/process-messages/index.js. Do not edit! -->\n\n### bind_invalid_checkbox_value\n\n```\nUsing `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n```\n\n### bind_invalid_export\n\n```\nComponent %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `\u003C%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n```\n\n### bind_not_bindable\n\n```\nA component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `\u003C%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n```\n\n### component_api_changed\n\n```\nCalling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5\n```\n\nSee the [migration guide](/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) for more information.\n\n### component_api_invalid_new\n\n```\nAttempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.\n```\n\nSee the [migration guide](/docs/svelte/v5-migration-guide#Components-are-no-longer-classes) for more information.\n\n### derived_references_self\n\n```\nA derived value cannot reference itself recursively\n```\n\n### each_key_duplicate\n\n```\nKeyed each block has duplicate key at indexes %a% and %b%\n```\n\n```\nKeyed each block has duplicate key `%value%` at indexes %a% and %b%\n```\n\n### effect_in_teardown\n\n```\n`%rune%` cannot be used inside an effect cleanup function\n```\n\n### effect_in_unowned_derived\n\n```\nEffect cannot be created inside a `$derived` value that was not itself created inside an effect\n```\n\n### effect_orphan\n\n```\n`%rune%` can only be used inside an effect (e.g. during component initialisation)\n```\n\n### effect_update_depth_exceeded\n\n```\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n```\n\n### hydration_failed\n\n```\nFailed to hydrate the application\n```\n\n### invalid_snippet\n\n```\nCould not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\n```\n\n### lifecycle_legacy_only\n\n```\n`%name%(...)` cannot be used in runes mode\n```\n\n### props_invalid_value\n\n```\nCannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n```\n\n### props_rest_readonly\n\n```\nRest element properties of `$props()` such as `%property%` are readonly\n```\n\n### rune_outside_svelte\n\n```\nThe `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n```\n\n### state_descriptors_fixed\n\n```\nProperty descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\n```\n\n### state_prototype_fixed\n\n```\nCannot set prototype of `$state` object\n```\n\n### state_unsafe_mutation\n\n```\nUpdating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\n```\n\nThis error occurs when state is updated while evaluating a `$derived`. You might encounter it while trying to 'derive' two pieces of state in one go:\n\n```svelte\n\u003Cscript>\n\tlet count = $state(0);\n\n\tlet even = $state(true);\n\n\tlet odd = $derived.by(() => {\n\t\teven = count % 2 === 0;\n\t\treturn !even;\n\t});\n\u003C/script>\n\n\u003Cbutton onclick={() => count++}>{count}\u003C/button>\n\n\u003Cp>{count} is even: {even}\u003C/p>\n\u003Cp>{count} is odd: {odd}\u003C/p>\n```\n\nThis is forbidden because it introduces instability: if `\u003Cp>{count} is even: {even}\u003C/p>` is updated before `odd` is recalculated, `even` will be stale. In most cases the solution is to make everything derived:\n\n```js\nlet count = 0;\n// ---cut---\nlet even = $derived(count % 2 === 0);\nlet odd = $derived(!even);\n```\n\nIf side-effects are unavoidable, use [`$effect`]($effect) instead.\n","## Client-side Runtime Errors\n\nReference of runtime errors that can occur in Svelte 5 applications.\n\n### Binding Errors\n- `bind_invalid_checkbox_value`: Use `bind:checked` instead of `bind:value` for checkboxes\n- `bind_invalid_export`: Cannot bind to exported properties; use `bind:this` to access component instance instead\n- `bind_not_bindable`: Property must be marked with `$bindable()` in component props to be bindable\n\n### Component API Changes (Svelte 5)\n- `component_api_changed`: Calling methods on component instances is no longer valid\n- `component_api_invalid_new`: Cannot instantiate components with `new`; set `compatibility.componentApi: 4` compiler option for v4 compatibility\n\n### Reactive State Errors\n- `derived_references_self`: Derived values cannot reference themselves recursively\n- `state_unsafe_mutation`: Cannot update state inside `$derived()`, `$inspect()`, or template expressions. Use `$effect` for side-effects instead.\n\nExample of forbidden pattern:\n```svelte\nlet count = $state(0);\nlet even = $state(true);\nlet odd = $derived.by(() => {\n  even = count % 2 === 0;  // forbidden\n  return !even;\n});\n```\n\nSolution - make everything derived:\n```js\nlet even = $derived(count % 2 === 0);\nlet odd = $derived(!even);\n```\n\n### Effect Errors\n- `effect_in_teardown`: Cannot use runes inside effect cleanup functions\n- `effect_in_unowned_derived`: Effects cannot be created inside `$derived` values unless the derived itself was created inside an effect\n- `effect_orphan`: Runes can only be used inside effects during component initialization\n- `effect_update_depth_exceeded`: Maximum update depth exceeded; prevents infinite loops\n\n### Other Errors\n- `each_key_duplicate`: Keyed each blocks have duplicate keys\n- `hydration_failed`: Application hydration failed\n- `invalid_snippet`: Cannot render null/undefined snippets; use optional chaining\n- `lifecycle_legacy_only`: Legacy lifecycle functions cannot be used in runes mode\n- `props_invalid_value`: Cannot bind undefined when property has a fallback value\n- `props_rest_readonly`: Rest element properties of `$props()` are readonly\n- `rune_outside_svelte`: Runes only available in `.svelte` and `.svelte.js/ts` files\n- `state_descriptors_fixed`: Property descriptors on `$state` objects must have `value` and be `enumerable`, `configurable`, `writable`\n- `state_prototype_fixed`: Cannot set prototype of `$state` objects","## Client-side Runtime Errors\n\nBinding: Use `bind:checked` for checkboxes, `bind:this` for component access, mark properties with `$bindable()`.\n\nComponent API (Svelte 5): Cannot call methods on instances or use `new` to instantiate.\n\nState: Cannot mutate state in `$derived()` or template expressions; use `$effect` for side-effects. Derived values cannot reference themselves.\n\nEffects: Only usable during component initialization; cannot be in cleanup functions or unowned derived values.\n\nOther: Keyed each blocks need unique keys, hydration can fail, snippets need null checks, runes only in `.svelte` files.","Reference of runtime errors in Svelte 5 with guidance on binding, component API changes, reactive state constraints, and effect usage."],"uses":{"params":["name","path"]}}]}
