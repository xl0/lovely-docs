{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","API Reference/Error & Warning Reference/client-warnings",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","98-reference/.generated/client-warnings.md",true,{"fulltext":8,"digest":9,"short_digest":10},2437,685,384,{"input":12,"output":13,"details":14},3473,1175,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"\u003C!-- This file is generated by scripts/process-messages/index.js. Do not edit! -->\n\n### assignment_value_stale\n\n```\nAssignment to `%property%` property (%location%) will evaluate to the right-hand side, not the value of `%property%` following the assignment. This may result in unexpected behaviour.\n```\n\nGiven a case like this...\n\n```svelte\n\u003Cscript>\n\tlet object = $state({ array: null });\n\n\tfunction add() {\n\t\t(object.array ??= []).push(object.array.length);\n\t}\n\u003C/script>\n\n\u003Cbutton onclick={add}>add\u003C/button>\n\u003Cp>items: {JSON.stringify(object.items)}\u003C/p>\n```\n\n...the array being pushed to when the button is first clicked is the `[]` on the right-hand side of the assignment, but the resulting value of `object.array` is an empty state proxy. As a result, the pushed value will be discarded.\n\nYou can fix this by separating it into two statements:\n\n```js\nlet object = { array: [0] };\n// ---cut---\nfunction add() {\n\tobject.array ??= [];\n\tobject.array.push(object.array.length);\n}\n```\n\n### binding_property_non_reactive\n\n```\n`%binding%` is binding to a non-reactive property\n```\n\n```\n`%binding%` (%location%) is binding to a non-reactive property\n```\n\n### console_log_state\n\n```\nYour `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` instead\n```\n\nWhen logging a [proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), browser devtools will log the proxy itself rather than the value it represents. In the case of Svelte, the 'target' of a `$state` proxy might not resemble its current value, which can be confusing.\n\nThe easiest way to log a value as it changes over time is to use the [`$inspect`](/docs/svelte/$inspect) rune. Alternatively, to log things on a one-off basis (for example, inside an event handler) you can use [`$state.snapshot`](/docs/svelte/$state#$state.snapshot) to take a snapshot of the current value.\n\n### event_handler_invalid\n\n```\n%handler% should be a function. Did you mean to %suggestion%?\n```\n\n### hydration_attribute_changed\n\n```\nThe `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value\n```\n\nCertain attributes like `src` on an `\u003Cimg>` element will not be repaired during hydration, i.e. the server value will be kept. That's because updating these attributes can cause the image to be refetched (or in the case of an `\u003Ciframe>`, for the frame to be reloaded), even if they resolve to the same resource.\n\nTo fix this, either silence the warning with a [`svelte-ignore`](basic-markup#Comments) comment, or ensure that the value stays the same between server and client. If you really need the value to change on hydration, you can force an update like this:\n\n```svelte\n\u003Cscript>\n\tlet { src } = $props();\n\n\tif (typeof window !== 'undefined') {\n\t\t// stash the value...\n\t\tconst initial = src;\n\n\t\t// unset it...\n\t\tsrc = undefined;\n\n\t\t$effect(() => {\n\t\t\t// ...and reset after we've mounted\n\t\t\tsrc = initial;\n\t\t});\n\t}\n\u003C/script>\n\n\u003Cimg {src} />\n```\n\n### hydration_html_changed\n\n```\nThe value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value\n```\n\n```\nThe value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value\n```\n\nIf the `{@html ...}` value changes between the server and the client, it will not be repaired during hydration, i.e. the server value will be kept. That's because change detection during hydration is expensive and usually unnecessary.\n\nTo fix this, either silence the warning with a [`svelte-ignore`](basic-markup#Comments) comment, or ensure that the value stays the same between server and client. If you really need the value to change on hydration, you can force an update like this:\n\n```svelte\n\u003Cscript>\n\tlet { markup } = $props();\n\n\tif (typeof window !== 'undefined') {\n\t\t// stash the value...\n\t\tconst initial = markup;\n\n\t\t// unset it...\n\t\tmarkup = undefined;\n\n\t\t$effect(() => {\n\t\t\t// ...and reset after we've mounted\n\t\t\tmarkup = initial;\n\t\t});\n\t}\n\u003C/script>\n\n{@html markup}\n```\n\n### hydration_mismatch\n\n```\nHydration failed because the initial UI does not match what was rendered on the server\n```\n\n```\nHydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%\n```\n\nThis warning is thrown when Svelte encounters an error while hydrating the HTML from the server. During hydration, Svelte walks the DOM, expecting a certain structure. If that structure is different (for example because the HTML was repaired by the DOM because of invalid HTML), then Svelte will run into issues, resulting in this warning.\n\nDuring development, this error is often preceeded by a `console.error` detailing the offending HTML, which needs fixing.\n\n### invalid_raw_snippet_render\n\n```\nThe `render` function passed to `createRawSnippet` should return HTML for a single element\n```\n\n### legacy_recursive_reactive_block\n\n```\nDetected a migrated `$:` reactive block in `%filename%` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an `$effect`.\n```\n\n### lifecycle_double_unmount\n\n```\nTried to unmount a component that was not mounted\n```\n\n### ownership_invalid_binding\n\n```\n%parent% passed property `%prop%` to %child% with `bind:`, but its parent component %owner% did not declare `%prop%` as a binding. Consider creating a binding between %owner% and %parent% (e.g. `bind:%prop%={...}` instead of `%prop%={...}`)\n```\n\nConsider three components `GrandParent`, `Parent` and `Child`. If you do `\u003CGrandParent bind:value>`, inside `GrandParent` pass on the variable via `\u003CParent {value} />` (note the missing `bind:`) and then do `\u003CChild bind:value>` inside `Parent`, this warning is thrown.\n\nTo fix it, `bind:` to the value instead of just passing a property (i.e. in this example do `\u003CParent bind:value />`).\n\n### ownership_invalid_mutation\n\n```\nMutating unbound props (`%name%`, at %location%) is strongly discouraged. Consider using `bind:%prop%={...}` in %parent% (or using a callback) instead\n```\n\nConsider the following code:\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport Child from './Child.svelte';\n\tlet person = $state({ name: 'Florida', surname: 'Man' });\n\u003C/script>\n\n\u003CChild {person} />\n```\n\n```svelte\n\u003C!--- file: Child.svelte --->\n\u003Cscript>\n\tlet { person } = $props();\n\u003C/script>\n\n\u003Cinput bind:value={person.name}>\n\u003Cinput bind:value={person.surname}>\n```\n\n`Child` is mutating `person` which is owned by `App` without being explicitly \"allowed\" to do so. This is strongly discouraged since it can create code that is hard to reason about at scale (\"who mutated this value?\"), hence the warning.\n\nTo fix it, either create callback props to communicate changes, or mark `person` as [`$bindable`]($bindable).\n\n### select_multiple_invalid_value\n\n```\nThe `value` property of a `\u003Cselect multiple>` element should be an array, but it received a non-array value. The selection will be kept as is.\n```\n\nWhen using `\u003Cselect multiple value={...}>`, Svelte will mark all selected `\u003Coption>` elements as selected by iterating over the array passed to `value`. If `value` is not an array, Svelte will emit this warning and keep the selected options as they are.\n\nTo silence the warning, ensure that `value`:\n\n- is an array for an explicit selection\n- is `null` or `undefined` to keep the selection as is\n\n### state_proxy_equality_mismatch\n\n```\nReactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results\n```\n\n`$state(...)` creates a [proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) of the value it is passed. The proxy and the value have different identities, meaning equality checks will always return `false`:\n\n```svelte\n\u003Cscript>\n\tlet value = { foo: 'bar' };\n\tlet proxy = $state(value);\n\n\tvalue === proxy; // always false\n\u003C/script>\n```\n\nTo resolve this, ensure you're comparing values where both values were created with `$state(...)`, or neither were. Note that `$state.raw(...)` will _not_ create a state proxy.\n\n### transition_slide_display\n\n```\nThe `slide` transition does not work correctly for elements with `display: %value%`\n```\n\nThe [slide](/docs/svelte/svelte-transition#slide) transition works by animating the `height` of the element, which requires a `display` style like `block`, `flex` or `grid`. It does not work for:\n\n- `display: inline` (which is the default for elements like `\u003Cspan>`), and its variants like `inline-block`, `inline-flex` and `inline-grid`\n- `display: table` and `table-[name]`, which are the defaults for elements like `\u003Ctable>` and `\u003Ctr>`\n- `display: contents`\n","## Client-side Warnings Reference\n\n### assignment_value_stale\nAssignment to a property using nullish coalescing assignment (`??=`) evaluates to the right-hand side value, not the assigned property. This causes mutations on the temporary value to be lost.\n\n```js\n// Problem: push happens on [], not object.array\n(object.array ??= []).push(object.array.length);\n\n// Fix: separate into two statements\nobject.array ??= [];\nobject.array.push(object.array.length);\n```\n\n### binding_property_non_reactive\nA binding targets a non-reactive property.\n\n### console_log_state\nLogging `$state` proxies shows the proxy object, not the value. Use `$inspect()` or `$state.snapshot()` instead.\n\n### event_handler_invalid\nEvent handler is not a function.\n\n### hydration_attribute_changed\nAn attribute value differs between server and client renders. The server value is kept during hydration. Fix by ensuring values match or use `svelte-ignore`. To force an update, unset the attribute and reset it in an `$effect`.\n\n### hydration_html_changed\nAn `{@html}` block value differs between server and client renders. The server value is kept. Fix by ensuring values match or use `svelte-ignore`. To force an update, unset the value and reset it in an `$effect`.\n\n### hydration_mismatch\nThe DOM structure doesn't match what was rendered on the server. Usually caused by invalid HTML that the browser repaired.\n\n### invalid_raw_snippet_render\nThe `render` function in `createRawSnippet` must return HTML for a single element.\n\n### legacy_recursive_reactive_block\nA migrated `$:` reactive block accesses and updates the same reactive value, which may cause recursive updates when converted to `$effect`.\n\n### lifecycle_double_unmount\nAttempted to unmount a component that wasn't mounted.\n\n### ownership_invalid_binding\nA parent component passed a property with `bind:` to a child, but the grandparent didn't declare it as a binding. Use `bind:` in the parent instead of just passing the property.\n\n### ownership_invalid_mutation\nMutating unbound props is discouraged. Use `bind:` in the parent or callbacks instead, or mark the prop as `$bindable`.\n\n### select_multiple_invalid_value\nA `\u003Cselect multiple>` element received a non-array value. Ensure `value` is an array or `null`/`undefined`.\n\n### state_proxy_equality_mismatch\n`$state()` creates a proxy with a different identity than the original value, so equality checks fail. Compare values where both or neither are created with `$state()`.\n\n### transition_slide_display\nThe `slide` transition animates height and requires `display: block`, `flex`, or `grid`. It doesn't work with `inline`, `inline-*`, `table`, `table-*`, or `contents`.","## Client Warnings\n\n**assignment_value_stale**: Nullish coalescing assignment (`??=`) evaluates to the RHS, not the assigned property. Separate into two statements.\n\n**binding_property_non_reactive**: Binding targets non-reactive property.\n\n**console_log_state**: Use `$inspect()` or `$state.snapshot()` instead of logging `$state` proxies.\n\n**event_handler_invalid**: Event handler is not a function.\n\n**hydration_attribute_changed/hydration_html_changed**: Server/client values differ. Ensure they match or use `svelte-ignore`. Force update by unsetting and resetting in `$effect`.\n\n**hydration_mismatch**: DOM structure doesn't match server render.\n\n**invalid_raw_snippet_render**: `createRawSnippet` render must return single element HTML.\n\n**legacy_recursive_reactive_block**: Migrated `$:` block accesses and updates same value, may cause recursion.\n\n**lifecycle_double_unmount**: Unmounting unmounted component.\n\n**ownership_invalid_binding**: Use `bind:` in parent instead of just passing property.\n\n**ownership_invalid_mutation**: Use `bind:` or callbacks instead of mutating unbound props, or mark as `$bindable`.\n\n**select_multiple_invalid_value**: `\u003Cselect multiple>` value must be array or null/undefined.\n\n**state_proxy_equality_mismatch**: `$state()` proxies have different identity. Compare consistently.\n\n**transition_slide_display**: `slide` transition requires `display: block/flex/grid`, not `inline/*` or `table/*`.","Reference guide for Svelte client-side runtime warnings with explanations and fixes."],"uses":{"params":["name","path"]}}]}
