{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Legacy Mode",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"directory","99-legacy",true,{"fulltext":8,"digest":9,"short_digest":10},1650,729,249,{"input":12,"output":13,"details":14},2830,1107,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"\n\n## Pages\n\n### legacy-overview\nOverview of deprecated Svelte 3/4 features in Svelte 5 and how legacy mode works alongside runes mode.\n\nSvelte 5 deprecated Svelte 3/4 features in favor of runes and snippets. Legacy mode features work in Svelte 5 until a component opts into runes mode with `runes: true` or by using runes.\n\n### reactive-let-var-declarations\nLegacy mode makes top-level variables reactive via assignments; mutations alone don't trigger updates without reassignment.\n\n## Reactive let/var in legacy mode\n\nTop-level variables are automatically reactive. Reactivity is assignment-based, so mutations like `.push()` require a reassignment to trigger updates:\n\n```svelte\nlet numbers = [1, 2, 3, 4];\nnumbers.push(5); // no update\nnumbers = numbers; // triggers update\n```\n\n### reactive-assignments-with-$:-statements\nLegacy Svelte reactive statements using $: prefix run when dependencies change and are topologically ordered by their references.\n\n## Reactive $: Statements (Legacy)\n\nPrefix top-level statements with `$:` to make them reactive—they re-run when dependencies change and are topologically ordered.\n\n```svelte\n\u003Cscript>\n\tlet a = 1, b = 2;\n\t$: sum = a + b;\n\t$: console.log(`${a} + ${b} = ${sum}`);\n\u003C/script>\n```\n\n**Key points:**\n- Dependencies determined at compile time by variable references\n- Indirect dependencies won't trigger re-runs\n- Statements run during SSR; wrap browser-only code: `$: if (browser) { ... }`\n\n### export-let\nLegacy mode component props are declared with export let, with optional defaults and renaming support.\n\n## Props in Legacy Mode\n\nDeclare props with `export let`:\n\n```svelte\n\u003Cscript>\n\texport let foo;\n\texport let bar = 'default value';\n\u003C/script>\n```\n\nProps without defaults are required. Set `undefined` as default to suppress warnings.\n\n## Component Exports\n\nExport functions/classes as public API:\n\n```svelte\n\u003Cscript>\n\texport function greet(name) {\n\t\talert(`hello ${name}!`);\n\t}\n\u003C/script>\n```\n\n## Renaming Props\n\n```svelte\n\u003Cscript>\n\tlet className;\n\texport { className as class };\n\u003C/script>\n```\n\n### $$props-and-$$restprops\nLegacy mode variables for accessing all component props or all undeclared props.\n\n## $$props and $$restProps\n\n- **`$$props`**: All props passed to component\n- **`$$restProps`**: All props except those declared with `export`\n\n```svelte\n\u003Cscript>\n\texport let variant;\n\u003C/script>\n\n\u003Cbutton {...$$restProps} class=\"variant-{variant} {$$props.class ?? ''}\">\n\tclick me\n\u003C/button>\n```\n\nNote: Modest performance penalty in Svelte 3/4, use only when needed.\n\n### legacy-event-handlers\nLegacy mode event handling with the on: directive, modifiers, event forwarding, and component event dispatching.\n\n## Event Handlers\n\nAttach handlers with `on:` directive:\n```svelte\n\u003Cbutton on:click={handleClick}>click me\u003C/button>\n\u003Cbutton on:click={() => count++}>inline\u003C/button>\n```\n\n## Modifiers\n\nChain modifiers with `|`:\n```svelte\n\u003Cform on:submit|preventDefault|once={handle}>\u003C/form>\n```\n\nAvailable: `preventDefault`, `stopPropagation`, `stopImmediatePropagation`, `passive`, `nonpassive`, `capture`, `once`, `self`, `trusted`\n\n## Event Forwarding\n\n```svelte\n\u003Cbutton on:click>forward event\u003C/button>\n```\n\n## Component Events\n\n```svelte\n\u003Cscript>\n\timport { createEventDispatcher } from 'svelte';\n\tconst dispatch = createEventDispatcher();\n\u003C/script>\n\u003Cbutton on:click={() => dispatch('increment')}>+\u003C/button>\n```\n\nListen on component: `\u003CStepper on:increment={() => n++} />`\n\nOnly `once` modifier works on component events. For Svelte 5, use callback props instead.\n\n### legacy-slots\nLegacy mode component content passing and rendering using slots with support for named slots, fallback content, and bidirectional data binding.\n\n## Legacy Slots\n\nRender slotted content with `\u003Cslot>`. Named slots use `slot=\"name\"` attribute. Provide fallback content inside `\u003Cslot>` tags. Pass data to slots with props and expose to parent using `let:` directive on both default and named slots.\n\n### $$slots\n$$slots is a legacy mode object that indicates which named slots were provided to a component by its parent.\n\nUse `$$slots` object in legacy mode to check if a named slot was provided. Keys are slot names passed by parent.\n\n```svelte\n{#if $$slots.description}\n\t\u003Cslot name=\"description\" />\n{/if}\n```\n\n### svelte:fragment\nLegacy element for placing content in named slots without a wrapping DOM element.\n\n`\u003Csvelte:fragment>` places content in named slots without a wrapping DOM element. Use it to preserve flow layout when filling multiple slots.\n\n```svelte\n\u003Csvelte:fragment slot=\"footer\">\n\t\u003Cp>All rights reserved.\u003C/p>\n\t\u003Cp>Copyright (c) 2019 Svelte Industries\u003C/p>\n\u003C/svelte:fragment>\n```\n\n**Legacy:** Obsolete in Svelte 5+ (snippets don't wrap).\n\n### svelte:component\nLegacy mode requires \u003Csvelte:component> to dynamically render components that change at runtime.\n\nIn legacy mode, use `\u003Csvelte:component this={MyComponent} />` to re-render when the component value changes. If `this` is falsy, nothing renders.\n\n### imperative-component-api\nSvelte 3/4 imperative API for instantiating components, updating props, listening to events, and server-side rendering.\n\n## Creating Components\n\n```ts\nconst app = new App({\n\ttarget: document.body,\n\tprops: { answer: 42 },\n\thydrate: false,\n\tintro: false\n});\n```\n\n## Instance Methods\n\n- `$set(props)` - update props (async)\n- `$on(event, callback)` - listen to events\n- `$destroy()` - cleanup\n\n## Props with Accessors\n\nWith `accessors: true`, props are synchronously settable:\n```ts\ncomponent.count += 1;\n```\n\n## Server-side Rendering\n\n```ts\nconst { head, html, css } = App.render({ answer: 42 });\n```\n\n**Note:** Svelte 5+ uses different APIs (`mount`, `unmount`, `$state`).\n\n### legacy-apis\nOverview of deprecated and legacy APIs in Svelte with guidance on modern replacements.\n\nDocumentation of legacy APIs maintained for backward compatibility in Svelte. Check here for deprecated features and their modern alternatives.\n\n","## Reactive Variables\n\nTop-level variables are automatically reactive. Mutations require reassignment to trigger updates:\n```svelte\nlet numbers = [1, 2, 3];\nnumbers.push(4); // no update\nnumbers = numbers; // triggers update\n```\n\n## Reactive Statements\n\nPrefix statements with `$:` to make them reactive—they re-run when dependencies change and are topologically ordered:\n```svelte\nlet a = 1, b = 2;\n$: sum = a + b;\n$: console.log(`${a} + ${b} = ${sum}`);\n```\n\nDependencies are determined at compile time. Wrap browser-only code: `$: if (browser) { ... }`\n\n## Props\n\nDeclare props with `export let`:\n```svelte\nexport let foo;\nexport let bar = 'default value';\n```\n\nRename props: `export { className as class };`\n\nAccess all props with `$$props` or undeclared props with `$$restProps`:\n```svelte\n\u003Cbutton {...$$restProps} class=\"variant-{$$props.class ?? ''}\">click me\u003C/button>\n```\n\n## Event Handlers\n\nAttach handlers with `on:` directive and chain modifiers with `|`:\n```svelte\n\u003Cbutton on:click={handleClick}>click me\u003C/button>\n\u003Cform on:submit|preventDefault|once={handle}>\u003C/form>\n```\n\nAvailable modifiers: `preventDefault`, `stopPropagation`, `stopImmediatePropagation`, `passive`, `nonpassive`, `capture`, `once`, `self`, `trusted`\n\nForward events: `\u003Cbutton on:click>forward event\u003C/button>`\n\nDispatch component events:\n```svelte\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\ndispatch('increment');\n```\n\nOnly `once` modifier works on component events.\n\n## Slots\n\nRender slotted content with `\u003Cslot>`. Named slots use `slot=\"name\"` attribute. Provide fallback content inside `\u003Cslot>` tags. Pass data to slots with props and expose to parent using `let:` directive.\n\nCheck if a named slot was provided with `$$slots`:\n```svelte\n{#if $$slots.description}\n\t\u003Cslot name=\"description\" />\n{/if}\n```\n\nUse `\u003Csvelte:fragment slot=\"name\">` to place content in named slots without a wrapping DOM element.\n\n## Dynamic Components\n\nUse `\u003Csvelte:component this={MyComponent} />` to dynamically render components that change at runtime.\n\n## Imperative API\n\nCreate components with:\n```ts\nconst app = new App({\n\ttarget: document.body,\n\tprops: { answer: 42 },\n\thydrate: false,\n\tintro: false\n});\n```\n\nInstance methods: `$set(props)`, `$on(event, callback)`, `$destroy()`\n\nWith `accessors: true`, props are synchronously settable: `component.count += 1;`\n\nServer-side rendering: `const { head, html, css } = App.render({ answer: 42 });`","## Reactive Variables & Statements\n\nTop-level variables are reactive; mutations require reassignment. Prefix statements with `$:` to make them reactive:\n```svelte\nlet count = 0;\ncount++; // no update\ncount = count; // triggers update\n$: doubled = count * 2;\n```\n\n## Props & Events\n\nDeclare props with `export let`. Dispatch events with `createEventDispatcher()`. Use `on:` directive with modifiers:\n```svelte\nexport let foo = 'default';\n\u003Cbutton on:click|preventDefault={handler}>click\u003C/button>\n```\n\n## Slots & Dynamic Components\n\nUse `\u003Cslot>` for content, `$$slots` to check if provided, `\u003Csvelte:fragment>` for wrapper-free slots, and `\u003Csvelte:component this={Comp} />` for dynamic rendering.\n\n## Imperative API\n\nCreate components with `new App({ target, props })`. Instance methods: `$set()`, `$on()`, `$destroy()`. Server-side render with `App.render()`.","Svelte 3/4 features deprecated in Svelte 5, including reactive variables, $: statements, export let props, event dispatching, slots, and imperative component APIs."],"uses":{"params":["name","path"]}}]}
