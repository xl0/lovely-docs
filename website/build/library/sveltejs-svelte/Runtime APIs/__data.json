{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runtime APIs",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"directory","06-runtime",true,{"fulltext":8,"digest":9,"short_digest":10},777,550,170,{"input":12,"output":13,"details":14},1863,830,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"\n\n## Pages\n\n### stores\nReactive state management through stores with a simple contract, with built-in implementations for writable, readable, derived, and readonly stores.\n\n## Stores\n\nReactive values accessed via `$` prefix in components. Svelte 5 runes reduce store necessity, but stores remain useful for async data streams and manual control.\n\n**API:**\n- `writable(initial, startFn?)` - Mutable store with `.set()` and `.update()`\n- `readable(initial, startFn)` - Immutable store\n- `derived(store(s), callback, initial?)` - Computed store\n- `readonly(store)` - Wraps store as read-only\n- `get(store)` - Get value without subscribing\n\n**Store Contract:** Must have `.subscribe(fn)` returning unsubscribe function, optionally `.set()` for writable stores.\n\n```js\nconst count = writable(0);\ncount.subscribe(v => console.log(v)); // logs 0\ncount.set(1); // logs 1\n```\n\n### context\nContext enables parent-to-child value passing without prop-drilling, with support for reactive state and type-safe patterns.\n\n## Context API\n\nAvoid prop-drilling by using `setContext(key, value)` in parent and `getContext(key)` in child components.\n\n```svelte\n// Parent\nsetContext('my-context', 'value');\n\n// Child\nconst value = getContext('my-context');\n```\n\nStore reactive state in context by mutating objects rather than reassigning them. Wrap `setContext`/`getContext` in helper functions for type safety. Context is request-isolated (safe for SSR), unlike global module state.\n\n### lifecycle-hooks\nSvelte 5 lifecycle consists of onMount and onDestroy hooks; use $effect runes instead of deprecated beforeUpdate/afterUpdate for granular state-change reactions.\n\n## onMount\nRuns when component mounts to DOM. Can return cleanup function (must be synchronous). Doesn't run on server.\n\n## onDestroy\nRuns before component unmounts. Only lifecycle hook that runs on server.\n\n## tick\nReturns promise that resolves after pending state changes apply. Use to ensure UI updates before continuing.\n\n## Deprecated: beforeUpdate / afterUpdate\nUse `$effect.pre` and `$effect` instead. These runes offer granular controlâ€”only react to explicitly referenced state.\n\nExample: autoscroll chat only when messages change:\n```svelte\n$effect.pre(() => {\n\tmessages;\n\tconst autoscroll = viewport?.offsetHeight + viewport?.scrollTop > viewport?.scrollHeight - 50;\n\tif (autoscroll) tick().then(() => viewport.scrollTo(0, viewport.scrollHeight));\n});\n```\n\n### imperative-component-api\nAPI for imperatively creating, mounting, unmounting, and server-rendering Svelte components.\n\n## mount\nInstantiates and mounts a component to a DOM element. Effects don't run during mount; use `flushSync()` if needed.\n\n## unmount\nRemoves a mounted component. Returns a Promise that resolves after transitions if `outro: true`.\n\n## render\nServer-only function returning `{ body, head }` for SSR.\n\n## hydrate\nLike mount but reuses server-rendered HTML. Effects don't run during hydrate.\n\n","## Stores\n\nReactive values accessed via `$` prefix. Svelte 5 runes reduce necessity, but stores remain useful for async data and manual control.\n\n- `writable(initial, startFn?)` - Mutable store with `.set()` and `.update()`\n- `readable(initial, startFn)` - Immutable store\n- `derived(store(s), callback, initial?)` - Computed store\n- `readonly(store)` - Read-only wrapper\n- `get(store)` - Get value without subscribing\n\nStore contract: `.subscribe(fn)` returning unsubscribe function, optionally `.set()` for writable stores.\n\n```js\nconst count = writable(0);\ncount.subscribe(v => console.log(v));\ncount.set(1);\n```\n\n## Context API\n\nPass values parent-to-child without prop-drilling using `setContext(key, value)` and `getContext(key)`. Store reactive state by mutating objects. Wrap in helpers for type safety. Context is request-isolated (safe for SSR).\n\n```svelte\n// Parent\nsetContext('my-context', 'value');\n// Child\nconst value = getContext('my-context');\n```\n\n## Lifecycle Hooks\n\n- `onMount` - Runs when component mounts to DOM, can return cleanup function, doesn't run on server\n- `onDestroy` - Runs before unmount, only hook that runs on server\n- `tick()` - Returns promise resolving after pending state changes apply\n- Use `$effect.pre` and `$effect` runes instead of deprecated `beforeUpdate`/`afterUpdate`\n\n```svelte\n$effect.pre(() => {\n\tmessages;\n\tconst autoscroll = viewport?.offsetHeight + viewport?.scrollTop > viewport?.scrollHeight - 50;\n\tif (autoscroll) tick().then(() => viewport.scrollTo(0, viewport.scrollHeight));\n});\n```\n\n## Imperative Component API\n\n- `mount(Component, options)` - Instantiate and mount component to DOM element\n- `unmount(component)` - Remove mounted component, returns Promise if `outro: true`\n- `render(Component, options)` - Server-only, returns `{ body, head }`\n- `hydrate(Component, options)` - Like mount but reuses server-rendered HTML","## Stores\nReactive values with `writable()`, `readable()`, `derived()`, `readonly()`, and `get()`. Contract: `.subscribe(fn)` returning unsubscribe.\n\n## Context API\n`setContext(key, value)` and `getContext(key)` for parent-to-child value passing without prop-drilling. Request-isolated for SSR.\n\n## Lifecycle\n`onMount`, `onDestroy`, `tick()`. Use `$effect.pre`/`$effect` instead of deprecated `beforeUpdate`/`afterUpdate`.\n\n## Imperative API\n`mount()`, `unmount()`, `render()` (server), `hydrate()` for component instantiation and rendering.","Core runtime APIs for state management, component lifecycle, context passing, and imperative component control in Svelte."],"uses":{"params":["name","path"]}}]}
