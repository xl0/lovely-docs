<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../../favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../../../_app/immutable/assets/0.CVnJD79Y.css" rel="stylesheet">
		<link rel="modulepreload" href="../../../_app/immutable/entry/start.B7sI1ods.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/CcrDhn4M.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/exV2Xogs.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/Kcep3NVP.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/BqKbMAXI.js">
		<link rel="modulepreload" href="../../../_app/immutable/entry/app.DiKKphzJ.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/PPVm8Dsz.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/D70RYpay.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/HjV3UwUe.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/DiQ6JDSX.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/BLcZWy6t.js">
		<link rel="modulepreload" href="../../../_app/immutable/nodes/0.CQvCJHGl.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/CgxbpIHi.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/CGGqTWd4.js">
		<link rel="modulepreload" href="../../../_app/immutable/nodes/4.CTUeGp_E.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/DTpGrtjP.js">
		<link rel="modulepreload" href="../../../_app/immutable/chunks/wncpRDzP.js"><!--1funsus--><!--[!--><!--]--> <!----><script>(function setInitialMode({ defaultMode = "system", themeColors: themeColors2, darkClassNames: darkClassNames2 = ["dark"], lightClassNames: lightClassNames2 = [], defaultTheme = "", modeStorageKey: modeStorageKey2 = "mode-watcher-mode", themeStorageKey: themeStorageKey2 = "mode-watcher-theme" }) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem(modeStorageKey2) ?? defaultMode;
  const theme = localStorage.getItem(themeStorageKey2) ?? defaultTheme;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  if (light) {
    if (darkClassNames2.length)
      rootEl.classList.remove(...darkClassNames2.filter(Boolean));
    if (lightClassNames2.length)
      rootEl.classList.add(...lightClassNames2.filter(Boolean));
  } else {
    if (lightClassNames2.length)
      rootEl.classList.remove(...lightClassNames2.filter(Boolean));
    if (darkClassNames2.length)
      rootEl.classList.add(...darkClassNames2.filter(Boolean));
  }
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  if (theme) {
    rootEl.setAttribute("data-theme", theme);
    localStorage.setItem(themeStorageKey2, theme);
  }
  localStorage.setItem(modeStorageKey2, mode);
})({"defaultMode":"system","darkClassNames":["dark"],"lightClassNames":[],"defaultTheme":"","modeStorageKey":"mode-watcher-mode","themeStorageKey":"mode-watcher-theme"});</script><!----><!---->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><!--[!--><!--]--><!----> <!----><div class="container mx-auto px-4 py-8 max-w-6xl"><div class="flex items-center justify-between mb-6"><nav class="flex items-center gap-2 text-sm text-muted-foreground"><a href="../../../" class="hover:text-foreground transition-colors">Home</a> <span>/</span> <a href="../../../library/sveltejs-svelte" class="hover:text-foreground transition-colors">sveltejs-svelte</a> <span>/</span> <!--[--><!--[!--><!--]--> <!--[!--><a href="../../../library/sveltejs-svelte/Runtime APIs" class="hover:text-foreground transition-colors">Runtime APIs</a><!--]--><!--[--><span>/</span><!--]--> <!--[--><span class="text-foreground">lifecycle-hooks</span><!--]--><!--]--></nav> <!--[!--><button data-slot="button" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&amp;_svg:not([class*='size-'])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-9" type="button" aria-label="Toggle theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="absolute h-5 w-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><!----></button><!--]--><!----></div> <div class="mb-6"><div class="flex items-center justify-between mb-2"><h1 class="text-3xl font-bold tracking-tight">lifecycle-hooks</h1> <!----><span data-slot="badge" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex w-fit shrink-0 items-center justify-center gap-1 overflow-hidden whitespace-nowrap rounded-full border px-2 py-0.5 text-xs font-medium transition-[color,box-shadow] focus-visible:ring-[3px] [&amp;>svg]:pointer-events-none [&amp;>svg]:size-3 bg-primary text-primary-foreground [a&amp;]:hover:bg-primary/90 border-transparent"><!---->✓ Relevant<!----><!----></span><!----><!----></div> <p class="text-sm text-muted-foreground font-mono">Path: 06-runtime/03-lifecycle-hooks.md</p> <!--[--><div class="mt-3 text-sm text-muted-foreground italic border-l-2 border-muted pl-3">Svelte 5 lifecycle consists of onMount and onDestroy hooks; use $effect runes instead of deprecated beforeUpdate/afterUpdate for granular state-change reactions.</div><!--]--></div> <div data-slot="card" class="bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm mb-6"><div data-slot="card-content" class="px-6"><div class="flex items-center justify-between gap-4"><div class="flex flex-wrap gap-2"><!--[--><!--[!--><button data-slot="button" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center whitespace-nowrap text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&amp;_svg:not([class*='size-'])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5" type="button"><!---->Full Text <!--[--><!--[--><span class="ml-1 text-xs opacity-70">(3,645 tok)</span><!--]--><!--]--><!----></button><!--]--><!--[!--><button data-slot="button" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center whitespace-nowrap text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&amp;_svg:not([class*='size-'])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 bg-primary text-primary-foreground shadow-xs hover:bg-primary/90 h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5" type="button"><!---->Digest <!--[--><!--[!--><!--[--><span class="ml-1 text-xs opacity-70">(21%)</span><!--]--><!--]--><!--]--><!----></button><!--]--><!--[!--><button data-slot="button" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center whitespace-nowrap text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&amp;_svg:not([class*='size-'])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5" type="button"><!---->Short Digest <!--[--><!--[!--><!--[!--><!--[--><span class="ml-1 text-xs opacity-70">(6%)</span><!--]--><!--]--><!--]--><!--]--><!----></button><!--]--><!--]--></div> <!--[!--><button data-slot="button" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center whitespace-nowrap text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&amp;_svg:not([class*='size-'])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5" type="button"><!---->Markdown<!----></button><!--]--><!----></div><!----></div><!----></div><!----> <div data-slot="card" class="bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm"><div data-slot="card-content" class="px-6 pt-6"><!--[--><!--[!--><div class="prose prose-slate dark:prose-invert max-w-none"><!----><!----></div><!--]--><!--]--><!----></div><!----></div><!----></div><!----><!----><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_vxksyg = {
						base: new URL("../../..", location).pathname.slice(0, -1),
						assets: "/lovely-docs"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../../_app/immutable/entry/start.B7sI1ods.js"),
						import("../../../_app/immutable/entry/app.DiKKphzJ.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data: [{type:"data",data:null,uses:{}},{type:"data",data:{libraryName:"sveltejs-svelte",itemPath:"Runtime APIs/lifecycle-hooks",docItem:{type:"page",path:"06-runtime/03-lifecycle-hooks.md",relevant:true,token_counts:{fulltext:3645,digest:781,short_digest:203},usage:{input:4684,output:1111,details:null},markdown:{fulltext:"---\ntitle: Lifecycle hooks\n---\n\n\u003C!-- - onMount/onDestroy\n- mention that `$effect` might be better for your use case\n- beforeUpdate/afterUpdate with deprecation notice?\n- or skip this entirely and only have it in the reference docs? -->\n\nIn Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between — when certain state is updated — is not related to the component as a whole; only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it's the (render) effects that the component sets up upon component initialization. Consequently, there's no such thing as a \"before update\"/\"after update\" hook.\n\n## `onMount`\n\nThe `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live _inside_ the component; it can be called from an external module).\n\n`onMount` does not run inside a component that is rendered on the server.\n\n```svelte\n\u003Cscript>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconsole.log('the component has mounted');\n\t});\n\u003C/script>\n```\n\nIf a function is returned from `onMount`, it will be called when the component is unmounted.\n\n```svelte\n\u003Cscript>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tconsole.log('beep');\n\t\t}, 1000);\n\n\t\treturn () => clearInterval(interval);\n\t});\n\u003C/script>\n```\n\n> [!NOTE] This behaviour will only work when the function passed to `onMount` _synchronously_ returns a value. `async` functions always return a `Promise`, and as such cannot _synchronously_ return a function.\n\n## `onDestroy`\n\nSchedules a callback to run immediately before the component is unmounted.\n\nOut of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.\n\n```svelte\n\u003Cscript>\n\timport { onDestroy } from 'svelte';\n\n\tonDestroy(() => {\n\t\tconsole.log('the component is being destroyed');\n\t});\n\u003C/script>\n```\n\n## `tick`\n\nWhile there's no \"after update\" hook, you can use `tick` to ensure that the UI is updated before continuing. `tick` returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.\n\n```svelte\n\u003Cscript>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('the component is about to update');\n\t\ttick().then(() => {\n\t\t\t\tconsole.log('the component just updated');\n\t\t});\n\t});\n\u003C/script>\n```\n\n## Deprecated: `beforeUpdate` / `afterUpdate`\n\nSvelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.\n\n```svelte\n\u003Cscript>\n\timport { beforeUpdate, afterUpdate } from 'svelte';\n\n\tbeforeUpdate(() => {\n\t\tconsole.log('the component is about to update');\n\t});\n\n\tafterUpdate(() => {\n\t\tconsole.log('the component just updated');\n\t});\n\u003C/script>\n```\n\nInstead of `beforeUpdate` use `$effect.pre` and instead of `afterUpdate` use `$effect` instead - these runes offer more granular control and only react to the changes you're actually interested in.\n\n### Chat window example\n\nTo implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were _already_ scrolled to the bottom), we need to measure the DOM before we update it.\n\nIn Svelte 4, we do this with `beforeUpdate`, but this is a flawed approach — it fires before _every_ update, whether it's relevant or not. In the example below, we need to introduce checks like `updatingMessages` to make sure we don't mess with the scroll position when someone toggles dark mode.\n\nWith runes, we can use `$effect.pre`, which behaves the same as `$effect` but runs before the DOM is updated. As long as we explicitly reference `messages` inside the effect body, it will run whenever `messages` changes, but _not_ when `theme` changes.\n\n`beforeUpdate`, and its equally troublesome counterpart `afterUpdate`, are therefore deprecated in Svelte 5.\n\n- [Before](/playground/untitled#H4sIAAAAAAAAE31WXa_bNgz9K6yL1QmWOLlrC-w6H8MeBgwY9tY9NfdBtmlbiywZkpyPBfnvo2zLcZK28AWuRPGI5OGhkEuQc4EmiL9eAskqDOLg97oOZoE9125jDigs0t6oRqfOsjap5rXd7uTO8qpW2sIFEsyVxn_qjFmcAcstar-xPN3DFXKtKgi768IVgQku0ELj3Lgs_kZjWIEGNpAzYXDlHWyJFZI1zJjeh4O5uvl_DY8oUkVeVoFuJKYls-_CGYS25Aboj0EtWNqel0wWoBoLTGZgmdgDS9zW4Uz4NsrswPHoyutN4xInkylstnBxdmIhh8m7xzqmoNE2Wq46n1RJQzEbq4g-JQSl7e-HDx-GdaTy3KD9E3lRWvj5Zu9QX1QN20dj7zyHz8s-1S6lW7Cpz3RnXTcm04hIlfdFuO8p2mQ5-3a06cqjrn559bF_2NHOnRZ5I1PLlXQNyQT-hedMHeUEDyjtdMxsa4n2eIbNhlTwhyRthaOKOmYtniwF6pwt0wXa6MBEg0OibZec27gz_dk3UrZ6hB2LLYoiv521Yd8Gt-foTrfhiCDP0lC9VUUhcDLU49Xe_9943cNvEArHfAjxeBTovvXiNpFynfEDpIIZs9kFbg52QbeNHWZzebz32s7xHco3nJAJl1nshmhz8dYOQJDyZetnbb2gTWe-vEeWlrfpZMavr56ldb29eNt6UXvgwgFbp_WC0tl2RK25rGk6lYz3nUI2lzvBXGHhPZPGWmKUXFNBKqdaW259wl_aHbiqoVIZdpE60Nax6IOujT0LbFFxIVTCxCRR2XloUcYNvSbnGHKBp763jHoj59xiZWJI0Wm0P_m3MSS985xkasn-cFq20xTDy3J5KFcjgUTD69BHdcHIjz431z28IqlxGcPSfdFnrGDZn6gD6lyo45zyHAD-btczf-98nhQxHEvKfeUtOVkSejD3q-9X7JbzjGtsdUxlKdFU8qGsT78uaw848syWMXz85Waq2Gnem4mAn3prweq4q6Y3JEpnqMmnPoFRgmd3ySW0LLRqSKlwYHriCvJvUs2yjMaaoA-XzTXLeGMe45zmhv_XAno3Mj0xF7USuqNvnE9H343QHlq-eAgxpbTPNR9yzUkgLjwSR0NK4wKoxy-jDg-9vy8sUSToakzW-9fX13Em9Q8T6Z26uZhBN36XUYo5q7ggLXBZoub2Ofv7g6GCZfTxe034NCjiudXj7Omla0eTfo7QBPOcYxbE7qG-vl3_B1G-_i_JCAAA)\n- [After](/playground/untitled#H4sIAAAAAAAAE31WXa-jNhD9K7PsdknUQJLurtRLPqo-VKrU1327uQ8GBnBjbGSb5KZR_nvHgMlXtyIS9njO-MyZGZRzUHCBJkhez4FkNQZJ8HvTBLPAnhq3MQcUFmlvVKszZ1mbTPPGbndyZ3ndKG3hDJZne7hAoVUNYY8JV-RBPgIt2AprhA18MpZZnIQ50_twuvLHNRrDSjRXj9fwiCJTBLIKdCsxq5j9EM4gtBU3QD8GjWBZd14xWYJqLTCZg2ViDyx1W4cz4dv0hsiB49FRHkyfsCgws3GjcTKZwmYLZ2feWc9o1W8zJQ2Fb62i5JUQRNRHgs-fx3WsisKg_RN5WVn4-WrvUd9VA9tH4-AcwbfFQIpkLWByvWzqSe2sk3kyjUlOec_XPU-3TRaz_75tuvKoi19e3OvipSpamVmupJM2F_gXnnJ1lBM8oLQjHceys8R7PMFms4HwD2lRhzeEe-EsvluSrHe2TJdo4wMTLY48XKwPzm0KGm2r5ajFtRYU4TWOY7-ddWHfxhDP0QkQhnf5PWRnVVkKnIx8fZsOb5dR16nwG4TCCRdCMphWQ7z1_DoOcp3zA2SCGbPZBa5jd0G_TRxmc36Me-mG6A7l60XIlMs8ce2-OXtrDyBItdz6qVjPadObzx-RZdV1nJjx64tXad1sz962njceOHfAzmk9JzrbXqg1lw3NkZL7vgE257t-uMDcO6attSSokpmgFqVMO2U93e_dDlzOUKsc-3t6zNZp6K9cG3sS2KGSUqiUiUmq8tNYoJwbmvpTAoXA96GyjCojI26xNglk6DpwOPm7NdRYp4ia0JL94bTqRiGB5WJxqFY37RGPoz3c6i4jP3rcUA7wmhqNywQW7om_YQ2L4UQdUBdCHSPiOQJ8bFcxHzeK0jKBY0XcV95SkCWlD9t-9eOM3TLKucauiyktJdpaPqT19ddF4wFHntsqgS-_XE01e48GMwnw02AtWZP02QyGVOkcNfk072CU4PkduZSWpVYt9SkcmJ64hPwHpWF5ziVls3wIFmmW89Y83vMeGf5PBxjcyPSkXNy10J18t3x6-a6CDtBq6SGklNKeazFyLahB3PVIGo2UbhOgGi9vKjzW_j6xVFFD17difXx5ebll0vwvkcGpn4sZ9MN3vqFYsJoL6gUuK9TcPrO_PxgzWMRfflSEr2NHPJf6lj1957rRpH8CNMG84JgHidUtXt4u_wK21LXERAgAAA==)\n\n\u003C!-- prettier-ignore -->\n```svelte\n\u003Cscript>\n\timport { ---beforeUpdate, afterUpdate,--- tick } from 'svelte';\n\n\t---let updatingMessages = false;---\n\tlet theme = +++$state('dark')+++;\n\tlet messages = +++$state([])+++;\n\n\tlet viewport;\n\n\t---beforeUpdate(() => {---\n\t+++$effect.pre(() => {+++\n\t\t---if (!updatingMessages) return;---\n\t\t+++messages;+++\n\t\tconst autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\n\t\tif (autoscroll) {\n\t\t\ttick().then(() => {\n\t\t\t\tviewport.scrollTo(0, viewport.scrollHeight);\n\t\t\t});\n\t\t}\n\n\t\t---updatingMessages = false;---\n\t});\n\n\tfunction handleKeydown(event) {\n\t\tif (event.key === 'Enter') {\n\t\t\tconst text = event.target.value;\n\t\t\tif (!text) return;\n\n\t\t\t---updatingMessages = true;---\n\t\t\tmessages = [...messages, text];\n\t\t\tevent.target.value = '';\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\ttheme = theme === 'dark' ? 'light' : 'dark';\n\t}\n\u003C/script>\n\n\u003Cdiv class:dark={theme === 'dark'}>\n\t\u003Cdiv bind:this={viewport}>\n\t\t{#each messages as message}\n\t\t\t\u003Cp>{message}\u003C/p>\n\t\t{/each}\n\t\u003C/div>\n\n\t\u003Cinput +++onkeydown+++={handleKeydown} />\n\n\t\u003Cbutton +++onclick+++={toggle}> Toggle dark mode \u003C/button>\n\u003C/div>\n```\n",digest:"## onMount\n\nSchedules a callback to run when the component mounts to the DOM. Must be called during component initialization. Does not run on server-side rendered components.\n\nIf a function is returned from `onMount`, it will be called when the component unmounts. Note: this only works with synchronous returns; async functions always return a Promise.\n\n```svelte\n\u003Cscript>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => console.log('beep'), 1000);\n\t\treturn () => clearInterval(interval);\n\t});\n\u003C/script>\n```\n\n## onDestroy\n\nSchedules a callback to run immediately before the component unmounts. This is the only lifecycle hook that runs in server-side rendered components.\n\n```svelte\n\u003Cscript>\n\timport { onDestroy } from 'svelte';\n\n\tonDestroy(() => {\n\t\tconsole.log('the component is being destroyed');\n\t});\n\u003C/script>\n```\n\n## tick\n\nReturns a promise that resolves once pending state changes have been applied, or in the next microtask if there are none. Use this when you need to ensure the UI is updated before continuing.\n\n```svelte\n\u003Cscript>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('about to update');\n\t\ttick().then(() => console.log('just updated'));\n\t});\n\u003C/script>\n```\n\n## Deprecated: beforeUpdate / afterUpdate\n\nSvelte 4 had hooks that ran before/after component updates. These are shimmed in Svelte 5 for backwards compatibility but not available in components using runes.\n\nUse `$effect.pre` instead of `beforeUpdate` and `$effect` instead of `afterUpdate`. These runes offer more granular control and only react to changes you explicitly reference.\n\nExample: autoscrolling chat window that only scrolls when messages change, not when theme changes:\n\n```svelte\n\u003Cscript>\n\timport { tick } from 'svelte';\n\n\tlet theme = $state('dark');\n\tlet messages = $state([]);\n\tlet viewport;\n\n\t$effect.pre(() => {\n\t\tmessages;\n\t\tconst autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\t\tif (autoscroll) {\n\t\t\ttick().then(() => viewport.scrollTo(0, viewport.scrollHeight));\n\t\t}\n\t});\n\n\tfunction handleKeydown(event) {\n\t\tif (event.key === 'Enter') {\n\t\t\tmessages = [...messages, event.target.value];\n\t\t\tevent.target.value = '';\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\ttheme = theme === 'dark' ? 'light' : 'dark';\n\t}\n\u003C/script>\n\n\u003Cdiv class:dark={theme === 'dark'}>\n\t\u003Cdiv bind:this={viewport}>\n\t\t{#each messages as message}\n\t\t\t\u003Cp>{message}\u003C/p>\n\t\t{/each}\n\t\u003C/div>\n\t\u003Cinput onkeydown={handleKeydown} />\n\t\u003Cbutton onclick={toggle}>Toggle dark mode\u003C/button>\n\u003C/div>\n```\n\nIn Svelte 5, the component lifecycle consists only of creation and destruction. State updates don't trigger component-level hooks; instead, effects react to specific state changes.",short_digest:"## onMount\nRuns when component mounts to DOM. Can return cleanup function (must be synchronous). Doesn't run on server.\n\n## onDestroy\nRuns before component unmounts. Only lifecycle hook that runs on server.\n\n## tick\nReturns promise that resolves after pending state changes apply. Use to ensure UI updates before continuing.\n\n## Deprecated: beforeUpdate / afterUpdate\nUse `$effect.pre` and `$effect` instead. These runes offer granular control—only react to explicitly referenced state.\n\nExample: autoscroll chat only when messages change:\n```svelte\n$effect.pre(() => {\n\tmessages;\n\tconst autoscroll = viewport?.offsetHeight + viewport?.scrollTop > viewport?.scrollHeight - 50;\n\tif (autoscroll) tick().then(() => viewport.scrollTo(0, viewport.scrollHeight));\n});\n```",essence:"Svelte 5 lifecycle consists of onMount and onDestroy hooks; use $effect runes instead of deprecated beforeUpdate/afterUpdate for granular state-change reactions."}}},uses:{params:["name","path"]}}],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
