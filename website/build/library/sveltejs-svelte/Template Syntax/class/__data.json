{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Template Syntax/class",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","03-template-syntax/18-class.md",true,{"fulltext":8,"digest":9,"short_digest":10},921,404,172,{"input":12,"output":13,"details":14},1960,695,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: class\n---\n\nThere are two ways to set classes on elements: the `class` attribute, and the `class:` directive.\n\n## Attributes\n\nPrimitive values are treated like any other attribute:\n\n```svelte\n\u003Cdiv class={large ? 'large' : 'small'}>...\u003C/div>\n```\n\n> [!NOTE]\n> For historical reasons, falsy values (like `false` and `NaN`) are stringified (`class=\"false\"`), though `class={undefined}` (or `null`) cause the attribute to be omitted altogether. In a future version of Svelte, all falsy values will cause `class` to be omitted.\n\n### Objects and arrays\n\nSince Svelte 5.16, `class` can be an object or array, and is converted to a string using [clsx](https://github.com/lukeed/clsx).\n\nIf the value is an object, the truthy keys are added:\n\n```svelte\n\u003Cscript>\n\tlet { cool } = $props();\n\u003C/script>\n\n\u003C!-- results in `class=\"cool\"` if `cool` is truthy,\n     `class=\"lame\"` otherwise -->\n\u003Cdiv class={{ cool, lame: !cool }}>...\u003C/div>\n```\n\nIf the value is an array, the truthy values are combined:\n\n```svelte\n\u003C!-- if `faded` and `large` are both truthy, results in\n     `class=\"saturate-0 opacity-50 scale-200\"` -->\n\u003Cdiv class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...\u003C/div>\n```\n\nNote that whether we're using the array or object form, we can set multiple classes simultaneously with a single condition, which is particularly useful if you're using things like Tailwind.\n\nArrays can contain arrays and objects, and clsx will flatten them. This is useful for combining local classes with props, for example:\n\n```svelte\n\u003C!--- file: Button.svelte --->\n\u003Cscript>\n\tlet props = $props();\n\u003C/script>\n\n\u003Cbutton {...props} class={['cool-button', props.class]}>\n\t{@render props.children?.()}\n\u003C/button>\n```\n\nThe user of this component has the same flexibility to use a mixture of objects, arrays and strings:\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport Button from './Button.svelte';\n\tlet useTailwind = $state(false);\n\u003C/script>\n\n\u003CButton\n\tonclick={() => useTailwind = true}\n\tclass={{ 'bg-blue-700 sm:w-1/2': useTailwind }}\n>\n\tAccept the inevitability of Tailwind\n\u003C/Button>\n```\n\nSvelte also exposes the `ClassValue` type, which is the type of value that the `class` attribute on elements accept. This is useful if you want to use a type-safe class name in component props:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { ClassValue } from 'svelte/elements';\n\n\tconst props: { class: ClassValue } = $props();\n\u003C/script>\n\n\u003Cdiv class={['original', props.class]}>...\u003C/div>\n```\n\n## The `class:` directive\n\nPrior to Svelte 5.16, the `class:` directive was the most convenient way to set classes on elements conditionally.\n\n```svelte\n\u003C!-- These are equivalent -->\n\u003Cdiv class={{ cool, lame: !cool }}>...\u003C/div>\n\u003Cdiv class:cool={cool} class:lame={!cool}>...\u003C/div>\n```\n\nAs with other directives, we can use a shorthand when the name of the class coincides with the value:\n\n```svelte\n\u003Cdiv class:cool class:lame={!cool}>...\u003C/div>\n```\n\n> [!NOTE] Unless you're using an older version of Svelte, consider avoiding `class:`, since the attribute is more powerful and composable.\n","## Setting Classes on Elements\n\nTwo approaches exist: the `class` attribute and the `class:` directive.\n\n### Class Attribute\n\n**Primitive values:**\n```svelte\n\u003Cdiv class={large ? 'large' : 'small'}>...\u003C/div>\n```\n\n**Objects and arrays (Svelte 5.16+):**\nObjects add truthy keys as classes:\n```svelte\n\u003Cdiv class={{ cool, lame: !cool }}>...\u003C/div>\n```\n\nArrays combine truthy values:\n```svelte\n\u003Cdiv class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...\u003C/div>\n```\n\nArrays and objects can be nested and flattened, useful for combining local classes with component props:\n```svelte\n\u003C!-- Button.svelte -->\n\u003Cbutton class={['cool-button', props.class]}>...\u003C/button>\n\n\u003C!-- App.svelte -->\n\u003CButton class={{ 'bg-blue-700 sm:w-1/2': useTailwind }}>...\u003C/Button>\n```\n\nUse the `ClassValue` type for type-safe class props:\n```svelte\nimport type { ClassValue } from 'svelte/elements';\nconst props: { class: ClassValue } = $props();\n```\n\n### Class Directive\n\nThe `class:` directive conditionally applies classes:\n```svelte\n\u003Cdiv class:cool={cool} class:lame={!cool}>...\u003C/div>\n```\n\nShorthand when name matches value:\n```svelte\n\u003Cdiv class:cool class:lame={!cool}>...\u003C/div>\n```\n\nThe `class` attribute is more powerful and composable; prefer it over `class:` in Svelte 5.16+.","## Setting Classes\n\n**Attribute approach (preferred in Svelte 5.16+):**\n- Strings: `class={condition ? 'large' : 'small'}`\n- Objects: `class={{ cool, lame: !cool }}`\n- Arrays: `class={[faded && 'saturate-0', large && 'scale-200']}`\n- Nested arrays/objects flatten automatically\n\n**Directive approach (legacy):**\n```svelte\n\u003Cdiv class:cool={cool} class:lame={!cool}>...\u003C/div>\n\u003C!-- shorthand: -->\n\u003Cdiv class:cool class:lame={!cool}>...\u003C/div>\n```\n\nUse `ClassValue` type for type-safe component props.","Two ways to set classes: the class attribute (supporting strings, objects, and arrays) and the class: directive, with the attribute being more powerful and composable."],"uses":{"params":["name","path"]}}]}
