{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Template Syntax",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"directory","03-template-syntax",true,{"fulltext":8,"digest":9,"short_digest":10},3217,983,415,{"input":12,"output":13,"details":14},4485,1519,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"\n\n## Pages\n\n### basic-markup\nSvelte template syntax for markup: tags, attributes with expressions, event listeners, text interpolation, and comments.\n\n## Tags\nLowercase tags are HTML elements, capitalized/dot-notation tags are components.\n\n## Attributes & Props\nAttributes support JavaScript expressions and shorthand: `\u003Cbutton disabled={!clickable}>` or `\u003Cbutton {disabled}>`. Boolean attributes are included if truthy. Spread multiple at once: `\u003CWidget a=\"b\" {...things} c=\"d\" />`.\n\n## Events\nListen with `on` prefix: `\u003Cbutton onclick={handler}>`. Event attributes are case-sensitive and delegated to root for performance. Use `svelte/events` `on` function to avoid `stopPropagation` issues.\n\n## Text expressions\nInclude expressions with braces: `\u003Ch1>Hello {name}!\u003C/h1>`. Null/undefined omitted, others stringified. Use `{@html}` for HTML (with XSS precautions).\n\n## Comments\nHTML comments work. `svelte-ignore` disables warnings. `@component` shows documentation on hover.\n\n### if-blocks\nConditional rendering using if blocks with else if and else clauses.\n\nConditionally render content with `{#if expression}...{/if}`. Chain conditions with `{:else if expression}` and `{:else}`:\n\n```svelte\n{#if porridge.temperature > 100}\n\t\u003Cp>too hot!\u003C/p>\n{:else if 80 > porridge.temperature}\n\t\u003Cp>too cold!\u003C/p>\n{:else}\n\t\u003Cp>just right!\u003C/p>\n{/if}\n```\n\n### each-block\nThe each block iterates over arrays and iterables, with optional keying for efficient updates, destructuring support, and else fallback.\n\n# Each Block\n\nIterate over arrays and iterables:\n\n```svelte\n{#each items as item}\n  \u003Cli>{item.name}\u003C/li>\n{/each}\n```\n\nWith index: `{#each items as item, i}`\n\n**Keyed blocks** for intelligent list updates:\n\n```svelte\n{#each items as item (item.id)}\n  \u003Cli>{item.name}\u003C/li>\n{/each}\n```\n\nSupports destructuring, rendering n times without items, and else blocks for empty lists.\n\n### key\nThe key block destroys and recreates its contents when an expression value changes, enabling component reinitialization and transition replay.\n\nThe `{#key expression}...{/key}` block destroys and recreates its contents when the expression changes. Useful for reinitializing components or replaying transitions:\n\n```svelte\n{#key value}\n\t\u003CComponent />\n{/key}\n```\n\n### await-blocks\nAwait blocks handle Promise states with optional pending, then, and catch branches.\n\n{#await} blocks branch on Promise states (pending, fulfilled, rejected):\n\n```svelte\n{#await promise}\n  \u003Cp>loading...\u003C/p>\n{:then value}\n  \u003Cp>{value}\u003C/p>\n{:catch error}\n  \u003Cp>{error.message}\u003C/p>\n{/await}\n```\n\nBranches can be omitted. SSR only renders pending state. Works with dynamic imports for lazy loading.\n\n### snippets\nSnippets are reusable markup components that can be passed as props to other components, with optional typing and support for parameters.\n\n## Snippets\n\nReusable markup chunks declared with `{#snippet name(params)}...{/snippet}` and rendered with `{@render name()}`.\n\n**Passing to components:**\n```svelte\n\u003C!-- Explicit -->\n\u003CTable {header} {row} />\n\n\u003C!-- Implicit - snippets inside component become props -->\n\u003CTable>\n\t{#snippet header()}...{/snippet}\n\t{#snippet row(d)}...{/snippet}\n\u003C/Table>\n\n\u003C!-- Content becomes children snippet -->\n\u003CButton>click me\u003C/Button>\n```\n\n**Typing:**\n```svelte\n\u003Cscript lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tlet { row }: { row: Snippet\u003C[any]> } = $props();\n\u003C/script>\n```\n\n**Optional snippets:** Use `{@render children?.()}` or `{#if children}` for fallback content.\n\n**Exporting:** Export from `\u003Cscript module>` if not referencing non-module declarations.\n\n### @render\nThe {@render ...} tag executes a snippet, supporting conditional expressions and optional chaining for undefined snippets.\n\n## {@render ...} tag\n\nRenders a snippet. Expression can be an identifier or JavaScript expression:\n\n```svelte\n{@render sum(1, 2)}\n{@render (cool ? coolSnippet : lameSnippet)()}\n```\n\nFor optional snippets, use optional chaining or if/else:\n\n```svelte\n{@render children?.()}\n{#if children}\n\t{@render children()}\n{:else}\n\t\u003Cp>fallback\u003C/p>\n{/if}\n```\n\n### @html-tag\nInject raw HTML with {@html ...} tag, sanitize input to prevent XSS, and use :global for styling.\n\nThe `{@html ...}` tag injects raw HTML. Always sanitize input to prevent XSS. The expression must be valid standalone HTML and won't receive scoped stylesâ€”use `:global` modifier for styling injected content.\n\n### @attach-directive\nAttachments are reactive functions that run when elements mount or state updates, with optional cleanup, and can be passed through components.\n\n## @attach directive\n\nFunctions that run in an effect when an element mounts or state updates. Return a cleanup function if needed.\n\n```svelte\nfunction myAttachment(element) {\n\treturn () => console.log('cleaning up');\n}\n\u003Cdiv {@attach myAttachment}>...\u003C/div>\n```\n\n**Attachment factories** - return attachments from functions for reusable patterns:\n```svelte\nfunction tooltip(content) {\n\treturn (element) => {\n\t\tconst tooltip = tippy(element, { content });\n\t\treturn tooltip.destroy;\n\t};\n}\n\u003Cbutton {@attach tooltip(content)}>Hover me\u003C/button>\n```\n\n**Inline attachments** - define directly on elements with nested effects for fine-grained reactivity.\n\n**Component props** - attachments passed to components are spread as Symbol-keyed props.\n\n**Controlling re-runs** - use nested effects to prevent expensive setup work from re-running on every state change.\n\n### @const\nDefine local constants within block scope using {@const ...} tag.\n\nThe `{@const ...}` tag defines a local constant within block scope.\n\n```svelte\n{#each boxes as box}\n\t{@const area = box.width * box.height}\n\t{area}\n{/each}\n```\n\nOnly allowed as immediate child of blocks (`{#if}`, `{#each}`, `{#snippet}`), components, or `\u003Csvelte:boundary>`.\n\n### @debug-tag\nDebug tag for logging variable changes and pausing execution in Svelte templates.\n\n`{@debug ...}` logs variable values on change and pauses execution with devtools open. Accepts comma-separated variable names only (not expressions). `{@debug}` without arguments triggers on any state change.\n\n### bind\nThe `bind:` directive enables two-way data binding between parent and child components or between components and DOM elements, with support for various input types, media controls, dimensions, and custom validation through function bindings.\n\n## Two-way Data Binding with `bind:`\n\nSyntax: `bind:property={expression}` or `bind:property` when identifier matches property name.\n\n**Input bindings:** `bind:value` (coerces to number for type=\"number\"), `bind:checked`, `bind:indeterminate`, `bind:group` (radio/checkbox groups), `bind:files`\n\n**Select:** `bind:value` binds to selected option value (any type); `\u003Cselect multiple>` binds to array\n\n**Media:** `\u003Caudio>`/`\u003Cvideo>` two-way: `currentTime`, `playbackRate`, `paused`, `volume`, `muted`; readonly: `duration`, `buffered`, `seekable`, `seeking`, `ended`, `readyState`, `played`\n\n**Other:** `\u003Cimg>` readonly `naturalWidth`/`naturalHeight`; `\u003Cdetails bind:open>`; contenteditable `innerHTML`/`innerText`/`textContent`; dimension bindings `clientWidth`, `clientHeight`, `offsetWidth`, `offsetHeight`, `contentRect`, `contentBoxSize`, `borderBoxSize`, `devicePixelContentBoxSize`; `bind:this` for DOM references\n\n**Components:** Mark props bindable with `$bindable()` rune to allow parent-to-child-to-parent flow\n\n**Function bindings:** `bind:property={get, set}` for validation; use `{null, set}` for readonly bindings\n\n### use:-directive\nThe use: directive attaches action functions to elements on mount, with setup/teardown via $effect and optional typing.\n\n## use: directive for actions\n\nActions are functions called on element mount via `use:` directive with `$effect` for setup/teardown:\n\n```svelte\nfunction myaction(node, data) {\n\t$effect(() => {\n\t\t// setup\n\t\treturn () => { /* teardown */ };\n\t});\n}\n\n\u003Cdiv use:myaction={data}>...\u003C/div>\n```\n\nType actions with `Action\u003CNodeType, ParamType, EventHandlers>` interface. Actions run once on mount, not during SSR, and don't re-run if arguments change.\n\n### transition\nTransitions animate elements entering/leaving the DOM with built-in or custom functions, supporting local/global scope, parameters, and lifecycle events.\n\n## Transitions\n\nUse `transition:` directive for bidirectional animations when elements enter/leave DOM:\n\n```svelte\n\u003Cdiv transition:fade>fades in and out\u003C/div>\n\u003Cdiv transition:fade|global>plays on parent changes too\u003C/div>\n\u003Cdiv transition:fade={{ duration: 2000 }}>custom duration\u003C/div>\n```\n\nCustom transitions return object with `css` or `tick` function:\n\n```js\nfunction whoosh(node, params) {\n  return {\n    duration: 400,\n    css: (t, u) => `transform: scale(${t})`\n  };\n}\n```\n\nEvents: `introstart`, `introend`, `outrostart`, `outroend`\n\n### in-and-out-directives\nin: and out: directives apply separate, non-bidirectional transitions to elements, with in transitions continuing to play alongside out transitions rather than reversing.\n\n`in:` and `out:` directives apply non-bidirectional transitions. The `in` transition plays alongside `out` rather than reversing if the block is outroed during the transition. Aborted `out` transitions restart from scratch.\n\n```svelte\n{#if visible}\n  \u003Cdiv in:fly={{ y: 200 }} out:fade>flies in, fades out\u003C/div>\n{/if}\n```\n\n### animate\nAnimations in keyed each blocks trigger on reordering; custom animation functions receive node and from/to DOMRect positions, returning css or tick-based animations.\n\n## Animations in Keyed Each Blocks\n\nAnimations trigger when elements in a keyed each block are reordered (not on add/remove). Use the `animate:` directive on immediate children:\n\n```svelte\n{#each list as item, index (item)}\n\t\u003Cli animate:flip={{ delay: 500 }}>{item}\u003C/li>\n{/each}\n```\n\n### Custom Animation Functions\n\nReturn an object with `delay`, `duration`, `easing`, and either `css` or `tick`:\n\n```js\nfunction whizz(node, { from, to }, params) {\n\tconst dx = from.left - to.left;\n\tconst dy = from.top - to.top;\n\tconst d = Math.sqrt(dx * dx + dy * dy);\n\t\n\treturn {\n\t\tduration: Math.sqrt(d) * 120,\n\t\teasing: cubicOut,\n\t\tcss: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n\t};\n}\n```\n\nPrefer `css` over `tick` for better performance (runs off main thread).\n\n### style-directive\nShorthand directive for setting inline styles on elements with support for dynamic values and important modifier.\n\nThe `style:` directive sets inline styles with shorthand syntax. Supports dynamic values, multiple styles, and `|important` modifier. Takes precedence over `style` attributes and `!important`.\n\n```svelte\n\u003Cdiv style:color=\"red\" style:width={w} style:background-color|important={bg}>...\u003C/div>\n```\n\n### class\nTwo ways to set classes: the class attribute (supporting strings, objects, and arrays) and the class: directive, with the attribute being more powerful and composable.\n\n## Setting Classes\n\n**Attribute approach (preferred in Svelte 5.16+):**\n- Strings: `class={condition ? 'large' : 'small'}`\n- Objects: `class={{ cool, lame: !cool }}`\n- Arrays: `class={[faded && 'saturate-0', large && 'scale-200']}`\n- Nested arrays/objects flatten automatically\n\n**Directive approach (legacy):**\n```svelte\n\u003Cdiv class:cool={cool} class:lame={!cool}>...\u003C/div>\n\u003C!-- shorthand: -->\n\u003Cdiv class:cool class:lame={!cool}>...\u003C/div>\n```\n\nUse `ClassValue` type for type-safe component props.\n\n### template-syntax\n\u003CUNKNOWN>\n\n\u003CUNKNOWN>\n\n","# Template Syntax\n\n## Markup & Attributes\nLowercase tags are HTML elements; capitalized/dot-notation tags are components. Attributes support JavaScript expressions and shorthand: `\u003Cbutton disabled={!clickable}>` or `\u003Cbutton {disabled}>`. Spread attributes: `\u003CWidget {...things} />`. Boolean attributes included if truthy.\n\n## Text & HTML\nInclude expressions with braces: `\u003Ch1>Hello {name}!\u003C/h1>`. Use `{@html}` for raw HTML (sanitize to prevent XSS). Null/undefined omitted, others stringified.\n\n## Events\nListen with `on` prefix: `\u003Cbutton onclick={handler}>`. Event attributes are case-sensitive and delegated to root for performance.\n\n## Conditional Rendering\n`{#if expression}...{:else if}...{:else}...{/if}` for conditional blocks.\n\n## Iteration\n`{#each items as item (item.id)}` iterates with optional keying for efficient updates. Supports destructuring and `{:else}` for empty lists.\n\n## Key Block\n`{#key expression}...{/key}` destroys and recreates contents when expression changes, useful for reinitializing components or replaying transitions.\n\n## Async Handling\n`{#await promise}...{:then value}...{:catch error}...{/await}` branches on Promise states. SSR only renders pending state.\n\n## Snippets\nReusable markup declared with `{#snippet name(params)}...{/snippet}` and rendered with `{@render name()}`. Pass to components explicitly or implicitly:\n```svelte\n\u003CTable {header} {row} />\n\u003C!-- or -->\n\u003CTable>\n  {#snippet header()}...{/snippet}\n  {#snippet row(d)}...{/snippet}\n\u003C/Table>\n```\nType with `Snippet\u003C[ParamType]>`. Use optional chaining for optional snippets: `{@render children?.()}`.\n\n## Directives\n\n**bind:** Two-way binding between components/DOM. `bind:value`, `bind:checked`, `bind:group` (radio/checkbox), `bind:files`. Media: `bind:currentTime`, `bind:paused`, `bind:volume`. Dimensions: `bind:clientWidth`, `bind:clientHeight`. Components: mark props with `$bindable()`. Function bindings for validation: `bind:property={get, set}`.\n\n**use:** Actions attached on mount via `use:myaction={data}`. Define with `$effect` for setup/teardown.\n\n**style:** Inline styles with shorthand: `style:color=\"red\" style:width={w} style:background-color|important={bg}`.\n\n**class:** Set classes via attribute (preferred): `class={condition ? 'large' : 'small'}` or `class={{ cool, lame: !cool }}`. Legacy directive: `class:cool={cool}`.\n\n**transition:** Bidirectional animations on enter/leave: `transition:fade={{ duration: 2000 }}` or `transition:fade|global`. Custom transitions return `{ duration, css(t, u) }` or `{ tick(t, u) }`. Events: `introstart`, `introend`, `outrostart`, `outroend`.\n\n**in:/out:** Non-bidirectional transitions. `in` plays alongside `out` rather than reversing: `in:fly={{ y: 200 }} out:fade`.\n\n**animate:** Reordering animations in keyed each blocks: `animate:flip={{ delay: 500 }}`. Custom functions receive `{ from, to }` DOMRect and return `{ duration, easing, css(t, u) }`.\n\n**@attach:** Reactive functions on mount/update: `{@attach myAttachment}`. Return cleanup function. Factories for reusable patterns: `{@attach tooltip(content)}`.\n\n**@const:** Local constants in block scope: `{@const area = box.width * box.height}`.\n\n**@debug:** Log variables on change: `{@debug variable}` or `{@debug}` for any state change.\n\n## Comments\nHTML comments work. `svelte-ignore` disables warnings. `@component` shows documentation on hover.","# Template Syntax\n\n**Markup:** Lowercase = HTML, capitalized = components. Attributes support expressions: `\u003Cbutton {disabled}>`. Spread: `\u003CWidget {...things} />`.\n\n**Text:** `\u003Ch1>Hello {name}!\u003C/h1>`. Use `{@html}` for raw HTML (sanitize).\n\n**Conditionals:** `{#if}...{:else if}...{:else}...{/if}`\n\n**Loops:** `{#each items as item (item.id)}...{:else}...{/each}`\n\n**Key block:** `{#key expr}` destroys/recreates on change.\n\n**Async:** `{#await promise}...{:then}...{:catch}...{/await}`\n\n**Snippets:** `{#snippet name(params)}...{/snippet}` rendered with `{@render name()}`. Pass to components or use `{@render children?.()}`.\n\n**Directives:**\n- `bind:value`, `bind:checked`, `bind:group`, `bind:files`, `bind:currentTime`, `bind:paused`, `bind:clientWidth`\n- `use:action={data}` with `$effect` for setup/teardown\n- `style:color=\"red\" style:width={w}`\n- `class={condition ? 'large' : 'small'}` or `class={{ cool }}`\n- `transition:fade={{ duration: 2000 }}` or `transition:fade|global`\n- `in:fly={{ y: 200 }} out:fade`\n- `animate:flip={{ delay: 500 }}` in keyed each blocks\n- `{@attach myAttachment}`, `{@const area = w * h}`, `{@debug var}`","Svelte's template syntax for markup, expressions, conditionals, loops, snippets, and reactive directives for binding, styling, transitions, and animations."],"uses":{"params":["name","path"]}}]}
