{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runes",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"directory","02-runes",true,{"fulltext":8,"digest":9,"short_digest":10},1384,594,142,{"input":12,"output":13,"details":14},2531,854,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"\n\n## Pages\n\n### what-are-runes\nRunes are $ -prefixed keywords in Svelte that control the compiler and differ from regular functions in that they cannot be imported, assigned, or passed as arguments.\n\nRunes are `$`-prefixed compiler keywords in Svelte (e.g., `$state('hello')`) that control the compiler. Unlike functions, they cannot be imported, assigned, or passed as arguments, and are only valid in specific positions.\n\n### $state\nThe $state rune creates reactive variables; arrays and objects become deeply reactive proxies, with variants for raw non-reactive state and snapshots.\n\n## $state Rune\n\nCreate reactive state with `$state(value)`. Arrays and plain objects become deeply reactive proxies:\n\n```js\nlet count = $state(0);\nlet todos = $state([{ done: false, text: 'add more todos' }]);\ntodos[0].done = !todos[0].done; // triggers update\n```\n\nUse `$state.raw` for non-reactive state that can only be reassigned. Use `$state.snapshot` to get a plain object from a proxy.\n\nFor class fields, use `$state` on individual fields. Destructuring breaks reactivity.\n\nWhen exporting state across modules, either export an object and mutate its properties, or export functions that access the state instead of exporting the state directly.\n\n### $derived\nDerived state automatically updates when its dependencies change, with support for complex expressions via $derived.by and temporary value overrides for optimistic UI.\n\n## $derived\n\nDeclare derived state that automatically updates when dependencies change:\n\n```svelte\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n```\n\nFor complex logic, use `$derived.by(() => { ... })`. Expressions must be side-effect free.\n\nCan temporarily override derived values for optimistic UI. Unlike `$state`, derived values aren't deeply reactive proxies, but mutations to objects/arrays from reactive state still affect the source.\n\nUses push-pull reactivity: dependents are notified immediately, but derived values only re-evaluate when read. Skips downstream updates if the new value is referentially identical to the previous one.\n\n### $effect\nEffects are side-effect functions that automatically track reactive dependencies and re-run when they change, with support for teardown functions and various execution modes.\n\n## $effect\n\nEffects run when state updates for side effects like API calls or canvas drawing. They automatically track reactive values ($state, $derived, $props) read synchronously and re-run when dependencies change.\n\n**Basic example:**\n```svelte\n$effect(() => {\n\tconst context = canvas.getContext('2d');\n\tcontext.fillStyle = color;\n\tcontext.fillRect(0, 0, size, size);\n});\n```\n\n**Teardown function** (runs before re-run or on destroy):\n```svelte\n$effect(() => {\n\tconst interval = setInterval(() => count += 1, ms);\n\treturn () => clearInterval(interval);\n});\n```\n\n**Key points:**\n- Only reruns when objects change, not properties inside them\n- Asynchronously read values are not tracked\n- Conditionally read values only create dependencies when the condition is true\n- Use $derived for state synchronization, not $effect\n- $effect.pre runs before DOM updates\n- $effect.tracking() checks if in tracking context\n- $effect.root() creates manually-controlled effects\n\n### $props\nThe $props rune receives component inputs with destructuring, fallback values, renaming, and type safety support.\n\n## $props rune\n\nReceive component props with destructuring:\n```svelte\nlet { adjective = 'happy' } = $props();\n```\n\nRename props: `let { super: trouper } = $props();`\n\nRest props: `let { a, b, ...others } = $props();`\n\nProps update reactively but shouldn't be mutated unless bindable. Add type safety with TypeScript or JSDoc.\n\nGenerate unique instance IDs with `$props.id()` for linking elements.\n\n### $bindable\nThe $bindable rune marks component props as bindable, enabling bidirectional data flow and allowing child components to mutate state that flows back to parents.\n\n## $bindable Rune\n\nEnables two-way data binding between parent and child components. Mark props with `$bindable()` to allow children to mutate and communicate changes back to parents.\n\n```svelte\n// Child\nlet { value = $bindable(), ...props } = $props();\n\n// Parent\n\u003CChild bind:value={message} />\n```\n\nUse sparingly; parents can still pass normal props without binding.\n\n### $inspect\nDevelopment-only rune for reactive logging and tracing state changes and their origins.\n\n## $inspect\n\nDevelopment-only rune that logs values whenever they change, tracking deep reactivity in objects and arrays.\n\n```svelte\n$inspect(count, message); // logs on change\n$inspect(count).with((type, value) => { /* custom handler */ });\n$inspect(stuff).with(console.trace); // find origin of changes\n```\n\n### $inspect.trace()\n\nTraces which reactive state caused an effect/derived to re-run. Must be first statement in function body.\n\n```svelte\n$effect(() => {\n\t$inspect.trace();\n\tdoSomeWork();\n});\n```\n\n### $host\n$host rune provides access to the host element for dispatching custom events in custom element components.\n\nThe `$host` rune accesses the host element in custom element components, enabling custom event dispatch:\n\n```svelte\n$host().dispatchEvent(new CustomEvent(type));\n```\n\n### runes\nRunes are Svelte's core reactive primitives for managing state, derived values, and side effects in components.\n\nRunes are Svelte's reactive primitives for state management. Key runes: `$state` for reactive variables, `$derived` for computed values, `$effect` for side effects, `$watch` for observing changes.\n\n","## Runes\n\nRunes are `$`-prefixed compiler keywords that control Svelte's reactivity. Unlike functions, they cannot be imported, assigned, or passed as arguments.\n\n### $state\nCreates reactive variables. Arrays and objects become deeply reactive proxies:\n```js\nlet count = $state(0);\nlet todos = $state([{ done: false, text: 'add more todos' }]);\ntodos[0].done = !todos[0].done; // triggers update\n```\nUse `$state.raw` for non-reactive state. Use `$state.snapshot()` to get a plain object from a proxy.\n\n### $derived\nDeclares computed state that automatically updates when dependencies change:\n```svelte\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n```\nFor complex logic, use `$derived.by(() => { ... })`. Expressions must be side-effect free. Uses push-pull reactivityâ€”dependents are notified immediately, but derived values only re-evaluate when read.\n\n### $effect\nRuns side-effect functions that automatically track reactive dependencies and re-run when they change:\n```svelte\n$effect(() => {\n\tconst context = canvas.getContext('2d');\n\tcontext.fillStyle = color;\n\tcontext.fillRect(0, 0, size, size);\n});\n```\nSupports teardown functions: `$effect(() => { const interval = setInterval(...); return () => clearInterval(interval); })`. Use `$effect.pre` to run before DOM updates. Use `$effect.root()` for manually-controlled effects.\n\n### $props\nReceives component inputs with destructuring and fallback values:\n```svelte\nlet { adjective = 'happy', super: trouper, ...others } = $props();\n```\nGenerate unique instance IDs with `$props.id()`.\n\n### $bindable\nMarks props as bindable to enable two-way data binding:\n```svelte\n// Child\nlet { value = $bindable() } = $props();\n// Parent\n\u003CChild bind:value={message} />\n```\n\n### $inspect\nDevelopment-only rune for reactive logging:\n```svelte\n$inspect(count, message); // logs on change\n$inspect(count).with((type, value) => { /* custom handler */ });\n$inspect.trace(); // traces which reactive state caused re-run\n```\n\n### $host\nAccesses the host element in custom element components:\n```svelte\n$host().dispatchEvent(new CustomEvent(type));\n```","## Runes\n\n`$`-prefixed compiler keywords for reactivity:\n\n- **$state**: Creates reactive variables; arrays/objects become deeply reactive proxies\n- **$derived**: Computed state that auto-updates on dependency changes\n- **$effect**: Side-effect functions that track dependencies and re-run on changes; supports teardown functions\n- **$props**: Receives component inputs with destructuring and defaults\n- **$bindable**: Enables two-way data binding on props\n- **$inspect**: Development-only reactive logging and tracing\n- **$host**: Accesses host element in custom element components","Runes are $-prefixed compiler keywords that manage reactive state, derived values, side effects, and component communication in Svelte."],"uses":{"params":["name","path"]}}]}
